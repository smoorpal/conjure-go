// This file was generated by Conjure and should not be manually edited.

package server

import (
	"github.com/palantir/conjure-go-runtime/conjure-go-contract/errors"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
	"github.com/tidwall/gjson"
)

type ClientTestCases struct {
	AutoDeserialize         map[EndpointName]PositiveAndNegativeTestCases
	SingleHeaderService     map[EndpointName][]string
	SinglePathParamService  map[EndpointName][]string
	SingleQueryParamService map[EndpointName][]string
}

func (o ClientTestCases) MarshalJSON() ([]byte, error) {
	if o.AutoDeserialize == nil {
		o.AutoDeserialize = make(map[EndpointName]PositiveAndNegativeTestCases, 0)
	}
	if o.SingleHeaderService == nil {
		o.SingleHeaderService = make(map[EndpointName][]string, 0)
	}
	if o.SinglePathParamService == nil {
		o.SinglePathParamService = make(map[EndpointName][]string, 0)
	}
	if o.SingleQueryParamService == nil {
		o.SingleQueryParamService = make(map[EndpointName][]string, 0)
	}
	type ClientTestCasesAlias ClientTestCases
	return safejson.Marshal(ClientTestCasesAlias(o))
}

func (o *ClientTestCases) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	value := gjson.ParseBytes(data)
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		switch key.Str {
		case "autoDeserialize":
			if !value.IsObject() {
				err = errors.NewInvalidArgument()
				return false
			}
			if o.AutoDeserialize == nil {
				o.AutoDeserialize = make(map[EndpointName]PositiveAndNegativeTestCases)
			}
			value.ForEach(func(key, value gjson.Result) bool {
				if key.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var destKey EndpointName
				destKey = EndpointName(key.Str)
				var destVal PositiveAndNegativeTestCases
				err = destVal.UnmarshalJSON([]byte(value.Raw))
				o.AutoDeserialize[destKey] = destVal
				return err == nil
			})
		case "singleHeaderService":
			if !value.IsObject() {
				err = errors.NewInvalidArgument()
				return false
			}
			if o.SingleHeaderService == nil {
				o.SingleHeaderService = make(map[EndpointName][]string)
			}
			value.ForEach(func(key, value gjson.Result) bool {
				if key.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var destKey EndpointName
				destKey = EndpointName(key.Str)
				var destVal []string
				if !value.IsArray() {
					err = errors.NewInvalidArgument()
					return false
				}
				value.ForEach(func(_, value gjson.Result) bool {
					if value.Type != gjson.String {
						err = errors.NewInvalidArgument()
						return false
					}
					var v string
					v = value.Str
					destVal = append(destVal, v)
					return err == nil
				})
				o.SingleHeaderService[destKey] = destVal
				return err == nil
			})
		case "singlePathParamService":
			if !value.IsObject() {
				err = errors.NewInvalidArgument()
				return false
			}
			if o.SinglePathParamService == nil {
				o.SinglePathParamService = make(map[EndpointName][]string)
			}
			value.ForEach(func(key, value gjson.Result) bool {
				if key.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var destKey EndpointName
				destKey = EndpointName(key.Str)
				var destVal []string
				if !value.IsArray() {
					err = errors.NewInvalidArgument()
					return false
				}
				value.ForEach(func(_, value gjson.Result) bool {
					if value.Type != gjson.String {
						err = errors.NewInvalidArgument()
						return false
					}
					var v string
					v = value.Str
					destVal = append(destVal, v)
					return err == nil
				})
				o.SinglePathParamService[destKey] = destVal
				return err == nil
			})
		case "singleQueryParamService":
			if !value.IsObject() {
				err = errors.NewInvalidArgument()
				return false
			}
			if o.SingleQueryParamService == nil {
				o.SingleQueryParamService = make(map[EndpointName][]string)
			}
			value.ForEach(func(key, value gjson.Result) bool {
				if key.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var destKey EndpointName
				destKey = EndpointName(key.Str)
				var destVal []string
				if !value.IsArray() {
					err = errors.NewInvalidArgument()
					return false
				}
				value.ForEach(func(_, value gjson.Result) bool {
					if value.Type != gjson.String {
						err = errors.NewInvalidArgument()
						return false
					}
					var v string
					v = value.Str
					destVal = append(destVal, v)
					return err == nil
				})
				o.SingleQueryParamService[destKey] = destVal
				return err == nil
			})
		}
		return err == nil
	})
	return err
}

func (o ClientTestCases) MarshalYAML() (interface{}, error) {
	jsonBytes, err := o.MarshalJSON()
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ClientTestCases) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}

type IgnoredClientTestCases struct {
	AutoDeserialize         map[EndpointName][]string
	SingleHeaderService     map[EndpointName][]string
	SinglePathParamService  map[EndpointName][]string
	SingleQueryParamService map[EndpointName][]string
}

func (o IgnoredClientTestCases) MarshalJSON() ([]byte, error) {
	if o.AutoDeserialize == nil {
		o.AutoDeserialize = make(map[EndpointName][]string, 0)
	}
	if o.SingleHeaderService == nil {
		o.SingleHeaderService = make(map[EndpointName][]string, 0)
	}
	if o.SinglePathParamService == nil {
		o.SinglePathParamService = make(map[EndpointName][]string, 0)
	}
	if o.SingleQueryParamService == nil {
		o.SingleQueryParamService = make(map[EndpointName][]string, 0)
	}
	type IgnoredClientTestCasesAlias IgnoredClientTestCases
	return safejson.Marshal(IgnoredClientTestCasesAlias(o))
}

func (o *IgnoredClientTestCases) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	value := gjson.ParseBytes(data)
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		switch key.Str {
		case "autoDeserialize":
			if !value.IsObject() {
				err = errors.NewInvalidArgument()
				return false
			}
			if o.AutoDeserialize == nil {
				o.AutoDeserialize = make(map[EndpointName][]string)
			}
			value.ForEach(func(key, value gjson.Result) bool {
				if key.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var destKey EndpointName
				destKey = EndpointName(key.Str)
				var destVal []string
				if !value.IsArray() {
					err = errors.NewInvalidArgument()
					return false
				}
				value.ForEach(func(_, value gjson.Result) bool {
					if value.Type != gjson.String {
						err = errors.NewInvalidArgument()
						return false
					}
					var v string
					v = value.Str
					destVal = append(destVal, v)
					return err == nil
				})
				o.AutoDeserialize[destKey] = destVal
				return err == nil
			})
		case "singleHeaderService":
			if !value.IsObject() {
				err = errors.NewInvalidArgument()
				return false
			}
			if o.SingleHeaderService == nil {
				o.SingleHeaderService = make(map[EndpointName][]string)
			}
			value.ForEach(func(key, value gjson.Result) bool {
				if key.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var destKey EndpointName
				destKey = EndpointName(key.Str)
				var destVal []string
				if !value.IsArray() {
					err = errors.NewInvalidArgument()
					return false
				}
				value.ForEach(func(_, value gjson.Result) bool {
					if value.Type != gjson.String {
						err = errors.NewInvalidArgument()
						return false
					}
					var v string
					v = value.Str
					destVal = append(destVal, v)
					return err == nil
				})
				o.SingleHeaderService[destKey] = destVal
				return err == nil
			})
		case "singlePathParamService":
			if !value.IsObject() {
				err = errors.NewInvalidArgument()
				return false
			}
			if o.SinglePathParamService == nil {
				o.SinglePathParamService = make(map[EndpointName][]string)
			}
			value.ForEach(func(key, value gjson.Result) bool {
				if key.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var destKey EndpointName
				destKey = EndpointName(key.Str)
				var destVal []string
				if !value.IsArray() {
					err = errors.NewInvalidArgument()
					return false
				}
				value.ForEach(func(_, value gjson.Result) bool {
					if value.Type != gjson.String {
						err = errors.NewInvalidArgument()
						return false
					}
					var v string
					v = value.Str
					destVal = append(destVal, v)
					return err == nil
				})
				o.SinglePathParamService[destKey] = destVal
				return err == nil
			})
		case "singleQueryParamService":
			if !value.IsObject() {
				err = errors.NewInvalidArgument()
				return false
			}
			if o.SingleQueryParamService == nil {
				o.SingleQueryParamService = make(map[EndpointName][]string)
			}
			value.ForEach(func(key, value gjson.Result) bool {
				if key.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var destKey EndpointName
				destKey = EndpointName(key.Str)
				var destVal []string
				if !value.IsArray() {
					err = errors.NewInvalidArgument()
					return false
				}
				value.ForEach(func(_, value gjson.Result) bool {
					if value.Type != gjson.String {
						err = errors.NewInvalidArgument()
						return false
					}
					var v string
					v = value.Str
					destVal = append(destVal, v)
					return err == nil
				})
				o.SingleQueryParamService[destKey] = destVal
				return err == nil
			})
		}
		return err == nil
	})
	return err
}

func (o IgnoredClientTestCases) MarshalYAML() (interface{}, error) {
	jsonBytes, err := o.MarshalJSON()
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *IgnoredClientTestCases) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}

type IgnoredTestCases struct {
	Client IgnoredClientTestCases
}

func (o IgnoredTestCases) MarshalJSON() ([]byte, error) {
	type IgnoredTestCasesAlias IgnoredTestCases
	return safejson.Marshal(IgnoredTestCasesAlias(o))
}

func (o *IgnoredTestCases) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	value := gjson.ParseBytes(data)
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		switch key.Str {
		case "client":
			err = o.Client.UnmarshalJSON([]byte(value.Raw))
		}
		return err == nil
	})
	return err
}

func (o IgnoredTestCases) MarshalYAML() (interface{}, error) {
	jsonBytes, err := o.MarshalJSON()
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *IgnoredTestCases) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}

type PositiveAndNegativeTestCases struct {
	Positive []string
	Negative []string
}

func (o PositiveAndNegativeTestCases) MarshalJSON() ([]byte, error) {
	if o.Positive == nil {
		o.Positive = make([]string, 0)
	}
	if o.Negative == nil {
		o.Negative = make([]string, 0)
	}
	type PositiveAndNegativeTestCasesAlias PositiveAndNegativeTestCases
	return safejson.Marshal(PositiveAndNegativeTestCasesAlias(o))
}

func (o *PositiveAndNegativeTestCases) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	value := gjson.ParseBytes(data)
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		switch key.Str {
		case "positive":
			if !value.IsArray() {
				err = errors.NewInvalidArgument()
				return false
			}
			value.ForEach(func(_, value gjson.Result) bool {
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var v string
				v = value.Str
				o.Positive = append(o.Positive, v)
				return err == nil
			})
		case "negative":
			if !value.IsArray() {
				err = errors.NewInvalidArgument()
				return false
			}
			value.ForEach(func(_, value gjson.Result) bool {
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var v string
				v = value.Str
				o.Negative = append(o.Negative, v)
				return err == nil
			})
		}
		return err == nil
	})
	return err
}

func (o PositiveAndNegativeTestCases) MarshalYAML() (interface{}, error) {
	jsonBytes, err := o.MarshalJSON()
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PositiveAndNegativeTestCases) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}

type TestCases struct {
	Client ClientTestCases
}

func (o TestCases) MarshalJSON() ([]byte, error) {
	type TestCasesAlias TestCases
	return safejson.Marshal(TestCasesAlias(o))
}

func (o *TestCases) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	value := gjson.ParseBytes(data)
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		switch key.Str {
		case "client":
			err = o.Client.UnmarshalJSON([]byte(value.Raw))
		}
		return err == nil
	})
	return err
}

func (o TestCases) MarshalYAML() (interface{}, error) {
	jsonBytes, err := o.MarshalJSON()
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TestCases) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}
