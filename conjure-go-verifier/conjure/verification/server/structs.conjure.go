// This file was generated by Conjure and should not be manually edited.

package server

import (
	"encoding/json"

	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
	wparams "github.com/palantir/witchcraft-go-params"
	"github.com/tidwall/gjson"
)

type ClientTestCases struct {
	AutoDeserialize         map[EndpointName]PositiveAndNegativeTestCases `json:"autoDeserialize"`
	SingleHeaderService     map[EndpointName][]string                     `json:"singleHeaderService"`
	SinglePathParamService  map[EndpointName][]string                     `json:"singlePathParamService"`
	SingleQueryParamService map[EndpointName][]string                     `json:"singleQueryParamService"`
}

func (o ClientTestCases) MarshalJSON() ([]byte, error) {
	if o.AutoDeserialize == nil {
		o.AutoDeserialize = make(map[EndpointName]PositiveAndNegativeTestCases, 0)
	}
	if o.SingleHeaderService == nil {
		o.SingleHeaderService = make(map[EndpointName][]string, 0)
	}
	if o.SinglePathParamService == nil {
		o.SinglePathParamService = make(map[EndpointName][]string, 0)
	}
	if o.SingleQueryParamService == nil {
		o.SingleQueryParamService = make(map[EndpointName][]string, 0)
	}
	type ClientTestCasesAlias ClientTestCases
	return safejson.Marshal(ClientTestCasesAlias(o))
}

func (o *ClientTestCases) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (o *ClientTestCases) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), false)
}

func (o *ClientTestCases) UnmarshalStrictJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), true)
}

func (o *ClientTestCases) UnmarshalStrictJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), true)
}

func (o *ClientTestCases) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	o.AutoDeserialize = make(map[EndpointName]PositiveAndNegativeTestCases, 0)
	o.SingleHeaderService = make(map[EndpointName][]string, 0)
	o.SinglePathParamService = make(map[EndpointName][]string, 0)
	o.SingleQueryParamService = make(map[EndpointName][]string, 0)
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "autoDeserialize":
			if !value.IsObject() {
				err = errors.NewInvalidArgument()
				return false
			}
			if o.AutoDeserialize == nil {
				o.AutoDeserialize = make(map[EndpointName]PositiveAndNegativeTestCases, 0)
			}
			value.ForEach(func(key, value gjson.Result) bool {
				if key.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var mapKey EndpointName
				mapKey = EndpointName(key.Str)
				var mapVal PositiveAndNegativeTestCases
				err = mapVal.UnmarshalJSON([]byte(value.Raw))
				o.AutoDeserialize[mapKey] = mapVal
				return err == nil
			})
		case "singleHeaderService":
			if !value.IsObject() {
				err = errors.NewInvalidArgument()
				return false
			}
			if o.SingleHeaderService == nil {
				o.SingleHeaderService = make(map[EndpointName][]string, 0)
			}
			value.ForEach(func(key, value gjson.Result) bool {
				if key.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				if !value.IsArray() {
					err = errors.NewInvalidArgument()
					return false
				}
				var mapKey EndpointName
				mapKey = EndpointName(key.Str)
				var mapVal []string
				value.ForEach(func(_, value gjson.Result) bool {
					if value.Type != gjson.String {
						err = errors.NewInvalidArgument()
						return false
					}
					var listElement1 string
					listElement1 = value.Str
					mapVal = append(mapVal, listElement1)
					return err == nil
				})
				o.SingleHeaderService[mapKey] = mapVal
				return err == nil
			})
		case "singlePathParamService":
			if !value.IsObject() {
				err = errors.NewInvalidArgument()
				return false
			}
			if o.SinglePathParamService == nil {
				o.SinglePathParamService = make(map[EndpointName][]string, 0)
			}
			value.ForEach(func(key, value gjson.Result) bool {
				if key.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				if !value.IsArray() {
					err = errors.NewInvalidArgument()
					return false
				}
				var mapKey EndpointName
				mapKey = EndpointName(key.Str)
				var mapVal []string
				value.ForEach(func(_, value gjson.Result) bool {
					if value.Type != gjson.String {
						err = errors.NewInvalidArgument()
						return false
					}
					var listElement1 string
					listElement1 = value.Str
					mapVal = append(mapVal, listElement1)
					return err == nil
				})
				o.SinglePathParamService[mapKey] = mapVal
				return err == nil
			})
		case "singleQueryParamService":
			if !value.IsObject() {
				err = errors.NewInvalidArgument()
				return false
			}
			if o.SingleQueryParamService == nil {
				o.SingleQueryParamService = make(map[EndpointName][]string, 0)
			}
			value.ForEach(func(key, value gjson.Result) bool {
				if key.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				if !value.IsArray() {
					err = errors.NewInvalidArgument()
					return false
				}
				var mapKey EndpointName
				mapKey = EndpointName(key.Str)
				var mapVal []string
				value.ForEach(func(_, value gjson.Result) bool {
					if value.Type != gjson.String {
						err = errors.NewInvalidArgument()
						return false
					}
					var listElement1 string
					listElement1 = value.Str
					mapVal = append(mapVal, listElement1)
					return err == nil
				})
				o.SingleQueryParamService[mapKey] = mapVal
				return err == nil
			})
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	if strict && len(unrecognizedFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields))
	}
	return nil
}

func (o ClientTestCases) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ClientTestCases) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}

type IgnoredClientTestCases struct {
	AutoDeserialize         map[EndpointName][]string `json:"autoDeserialize"`
	SingleHeaderService     map[EndpointName][]string `json:"singleHeaderService"`
	SinglePathParamService  map[EndpointName][]string `json:"singlePathParamService"`
	SingleQueryParamService map[EndpointName][]string `json:"singleQueryParamService"`
}

func (o IgnoredClientTestCases) MarshalJSON() ([]byte, error) {
	if o.AutoDeserialize == nil {
		o.AutoDeserialize = make(map[EndpointName][]string, 0)
	}
	if o.SingleHeaderService == nil {
		o.SingleHeaderService = make(map[EndpointName][]string, 0)
	}
	if o.SinglePathParamService == nil {
		o.SinglePathParamService = make(map[EndpointName][]string, 0)
	}
	if o.SingleQueryParamService == nil {
		o.SingleQueryParamService = make(map[EndpointName][]string, 0)
	}
	type IgnoredClientTestCasesAlias IgnoredClientTestCases
	return safejson.Marshal(IgnoredClientTestCasesAlias(o))
}

func (o *IgnoredClientTestCases) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (o *IgnoredClientTestCases) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), false)
}

func (o *IgnoredClientTestCases) UnmarshalStrictJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), true)
}

func (o *IgnoredClientTestCases) UnmarshalStrictJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), true)
}

func (o *IgnoredClientTestCases) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	o.AutoDeserialize = make(map[EndpointName][]string, 0)
	o.SingleHeaderService = make(map[EndpointName][]string, 0)
	o.SinglePathParamService = make(map[EndpointName][]string, 0)
	o.SingleQueryParamService = make(map[EndpointName][]string, 0)
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "autoDeserialize":
			if !value.IsObject() {
				err = errors.NewInvalidArgument()
				return false
			}
			if o.AutoDeserialize == nil {
				o.AutoDeserialize = make(map[EndpointName][]string, 0)
			}
			value.ForEach(func(key, value gjson.Result) bool {
				if key.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				if !value.IsArray() {
					err = errors.NewInvalidArgument()
					return false
				}
				var mapKey EndpointName
				mapKey = EndpointName(key.Str)
				var mapVal []string
				value.ForEach(func(_, value gjson.Result) bool {
					if value.Type != gjson.String {
						err = errors.NewInvalidArgument()
						return false
					}
					var listElement1 string
					listElement1 = value.Str
					mapVal = append(mapVal, listElement1)
					return err == nil
				})
				o.AutoDeserialize[mapKey] = mapVal
				return err == nil
			})
		case "singleHeaderService":
			if !value.IsObject() {
				err = errors.NewInvalidArgument()
				return false
			}
			if o.SingleHeaderService == nil {
				o.SingleHeaderService = make(map[EndpointName][]string, 0)
			}
			value.ForEach(func(key, value gjson.Result) bool {
				if key.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				if !value.IsArray() {
					err = errors.NewInvalidArgument()
					return false
				}
				var mapKey EndpointName
				mapKey = EndpointName(key.Str)
				var mapVal []string
				value.ForEach(func(_, value gjson.Result) bool {
					if value.Type != gjson.String {
						err = errors.NewInvalidArgument()
						return false
					}
					var listElement1 string
					listElement1 = value.Str
					mapVal = append(mapVal, listElement1)
					return err == nil
				})
				o.SingleHeaderService[mapKey] = mapVal
				return err == nil
			})
		case "singlePathParamService":
			if !value.IsObject() {
				err = errors.NewInvalidArgument()
				return false
			}
			if o.SinglePathParamService == nil {
				o.SinglePathParamService = make(map[EndpointName][]string, 0)
			}
			value.ForEach(func(key, value gjson.Result) bool {
				if key.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				if !value.IsArray() {
					err = errors.NewInvalidArgument()
					return false
				}
				var mapKey EndpointName
				mapKey = EndpointName(key.Str)
				var mapVal []string
				value.ForEach(func(_, value gjson.Result) bool {
					if value.Type != gjson.String {
						err = errors.NewInvalidArgument()
						return false
					}
					var listElement1 string
					listElement1 = value.Str
					mapVal = append(mapVal, listElement1)
					return err == nil
				})
				o.SinglePathParamService[mapKey] = mapVal
				return err == nil
			})
		case "singleQueryParamService":
			if !value.IsObject() {
				err = errors.NewInvalidArgument()
				return false
			}
			if o.SingleQueryParamService == nil {
				o.SingleQueryParamService = make(map[EndpointName][]string, 0)
			}
			value.ForEach(func(key, value gjson.Result) bool {
				if key.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				if !value.IsArray() {
					err = errors.NewInvalidArgument()
					return false
				}
				var mapKey EndpointName
				mapKey = EndpointName(key.Str)
				var mapVal []string
				value.ForEach(func(_, value gjson.Result) bool {
					if value.Type != gjson.String {
						err = errors.NewInvalidArgument()
						return false
					}
					var listElement1 string
					listElement1 = value.Str
					mapVal = append(mapVal, listElement1)
					return err == nil
				})
				o.SingleQueryParamService[mapKey] = mapVal
				return err == nil
			})
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	if strict && len(unrecognizedFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields))
	}
	return nil
}

func (o IgnoredClientTestCases) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *IgnoredClientTestCases) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}

type IgnoredTestCases struct {
	Client IgnoredClientTestCases `json:"client"`
}

func (o IgnoredTestCases) MarshalJSON() ([]byte, error) {
	type IgnoredTestCasesAlias IgnoredTestCases
	return safejson.Marshal(IgnoredTestCasesAlias(o))
}

func (o *IgnoredTestCases) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (o *IgnoredTestCases) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), false)
}

func (o *IgnoredTestCases) UnmarshalStrictJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), true)
}

func (o *IgnoredTestCases) UnmarshalStrictJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), true)
}

func (o *IgnoredTestCases) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var seenClient bool
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "client":
			seenClient = true
			err = o.Client.UnmarshalJSON([]byte(value.Raw))
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	var missingFields []string
	if !seenClient {
		missingFields = append(missingFields, "client")
	}
	if len(missingFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("missingFields", missingFields))
	}
	if strict && len(unrecognizedFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields))
	}
	return nil
}

func (o IgnoredTestCases) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *IgnoredTestCases) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}

type PositiveAndNegativeTestCases struct {
	Positive []string `json:"positive"`
	Negative []string `json:"negative"`
}

func (o PositiveAndNegativeTestCases) MarshalJSON() ([]byte, error) {
	if o.Positive == nil {
		o.Positive = make([]string, 0)
	}
	if o.Negative == nil {
		o.Negative = make([]string, 0)
	}
	type PositiveAndNegativeTestCasesAlias PositiveAndNegativeTestCases
	return safejson.Marshal(PositiveAndNegativeTestCasesAlias(o))
}

func (o *PositiveAndNegativeTestCases) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (o *PositiveAndNegativeTestCases) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), false)
}

func (o *PositiveAndNegativeTestCases) UnmarshalStrictJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), true)
}

func (o *PositiveAndNegativeTestCases) UnmarshalStrictJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), true)
}

func (o *PositiveAndNegativeTestCases) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	o.Positive = make([]string, 0)
	o.Negative = make([]string, 0)
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "positive":
			if !value.IsArray() {
				err = errors.NewInvalidArgument()
				return false
			}
			value.ForEach(func(_, value gjson.Result) bool {
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var listElement string
				listElement = value.Str
				o.Positive = append(o.Positive, listElement)
				return err == nil
			})
		case "negative":
			if !value.IsArray() {
				err = errors.NewInvalidArgument()
				return false
			}
			value.ForEach(func(_, value gjson.Result) bool {
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var listElement string
				listElement = value.Str
				o.Negative = append(o.Negative, listElement)
				return err == nil
			})
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	if strict && len(unrecognizedFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields))
	}
	return nil
}

func (o PositiveAndNegativeTestCases) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PositiveAndNegativeTestCases) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}

type TestCases struct {
	Client ClientTestCases `json:"client"`
}

func (o TestCases) MarshalJSON() ([]byte, error) {
	type TestCasesAlias TestCases
	return safejson.Marshal(TestCasesAlias(o))
}

func (o *TestCases) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (o *TestCases) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), false)
}

func (o *TestCases) UnmarshalStrictJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), true)
}

func (o *TestCases) UnmarshalStrictJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), true)
}

func (o *TestCases) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var seenClient bool
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "client":
			seenClient = true
			err = o.Client.UnmarshalJSON([]byte(value.Raw))
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	var missingFields []string
	if !seenClient {
		missingFields = append(missingFields, "client")
	}
	if len(missingFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("missingFields", missingFields))
	}
	if strict && len(unrecognizedFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields))
	}
	return nil
}

func (o TestCases) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TestCases) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}
