// This file was generated by Conjure and should not be manually edited.

package types

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
	wparams "github.com/palantir/witchcraft-go-params"
	"github.com/tidwall/gjson"
)

// A type which can either be a StringExample, a set of strings, or an integer.
type Union struct {
	typ                  string
	stringExample        *StringExample
	set                  *[]string
	thisFieldIsAnInteger *int
	alsoAnInteger        *int
	if_                  *int
	new                  *int
	interface_           *int
}

func (u *Union) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %s", u.typ)
	case "stringExample":
		return struct {
			Type          string        `json:"type"`
			StringExample StringExample `json:"stringExample"`
		}{Type: "stringExample", StringExample: *u.stringExample}, nil
	case "set":
		return struct {
			Type string   `json:"type"`
			Set  []string `json:"set"`
		}{Type: "set", Set: *u.set}, nil
	case "thisFieldIsAnInteger":
		return struct {
			Type                 string `json:"type"`
			ThisFieldIsAnInteger int    `json:"thisFieldIsAnInteger"`
		}{Type: "thisFieldIsAnInteger", ThisFieldIsAnInteger: *u.thisFieldIsAnInteger}, nil
	case "alsoAnInteger":
		return struct {
			Type          string `json:"type"`
			AlsoAnInteger int    `json:"alsoAnInteger"`
		}{Type: "alsoAnInteger", AlsoAnInteger: *u.alsoAnInteger}, nil
	case "if":
		return struct {
			Type string `json:"type"`
			If   int    `json:"if"`
		}{Type: "if", If: *u.if_}, nil
	case "new":
		return struct {
			Type string `json:"type"`
			New  int    `json:"new"`
		}{Type: "new", New: *u.new}, nil
	case "interface":
		return struct {
			Type      string `json:"type"`
			Interface int    `json:"interface"`
		}{Type: "interface", Interface: *u.interface_}, nil
	}
}

func (u Union) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u Union) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

// UnmarshalJSON deserializes data, ignoring unrecognized keys.
// Prefer UnmarshalJSONString if data is already in string form to avoid an extra copy.
func (u *Union) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return u.unmarshalGJSON(gjson.ParseBytes(data), false)
}

// UnmarshalJSONString deserializes data, ignoring unrecognized keys.
func (u *Union) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return u.unmarshalGJSON(gjson.Parse(data), false)
}

// UnmarshalJSONStrict deserializes data, rejecting unrecognized keys.
// Prefer UnmarshalJSONStringStrict if data is already in string form to avoid an extra copy.
func (u *Union) UnmarshalJSONStrict(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return u.unmarshalGJSON(gjson.ParseBytes(data), true)
}

// UnmarshalJSONStringStrict deserializes data, rejecting unrecognized keys.
func (u *Union) UnmarshalJSONStringStrict(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return u.unmarshalGJSON(gjson.Parse(data), true)
}

// UnmarshalYAML implements yaml.Unmarshaler. It converts the YAML to JSON, then runs UnmarshalJSON.
func (u *Union) UnmarshalYAML(unmarshal func(interface{}) error) error {
	data, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return errors.WrapWithInvalidArgument(err)
	}
	return u.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (u *Union) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var seentyp bool
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "type":
			seentyp = true
			if value.Type != gjson.String {
				err = errors.NewInvalidArgument()
				return false
			}
			u.typ = value.Str
		case "stringExample":
			if value.Type != gjson.Null {
				var optionalValue StringExample
				if strict {
					err = optionalValue.UnmarshalJSONStringStrict(value.Raw)
				} else {
					err = optionalValue.UnmarshalJSONString(value.Raw)
				}
				u.stringExample = &optionalValue
			}
		case "set":
			if value.Type != gjson.Null {
				if !value.IsArray() {
					err = errors.NewInvalidArgument()
					return false
				}
				var optionalValue []string
				value.ForEach(func(_, value gjson.Result) bool {
					if value.Type != gjson.String {
						err = errors.NewInvalidArgument()
						return false
					}
					var listElement1 string
					listElement1 = value.Str
					optionalValue = append(optionalValue, listElement1)
					return err == nil
				})
				u.set = &optionalValue
			}
		case "thisFieldIsAnInteger":
			if value.Type != gjson.Null {
				if value.Type != gjson.Number {
					err = errors.NewInvalidArgument()
					return false
				}
				var optionalValue int
				optionalValue = int(value.Int())
				u.thisFieldIsAnInteger = &optionalValue
			}
		case "alsoAnInteger":
			if value.Type != gjson.Null {
				if value.Type != gjson.Number {
					err = errors.NewInvalidArgument()
					return false
				}
				var optionalValue int
				optionalValue = int(value.Int())
				u.alsoAnInteger = &optionalValue
			}
		case "if":
			if value.Type != gjson.Null {
				if value.Type != gjson.Number {
					err = errors.NewInvalidArgument()
					return false
				}
				var optionalValue int
				optionalValue = int(value.Int())
				u.if_ = &optionalValue
			}
		case "new":
			if value.Type != gjson.Null {
				if value.Type != gjson.Number {
					err = errors.NewInvalidArgument()
					return false
				}
				var optionalValue int
				optionalValue = int(value.Int())
				u.new = &optionalValue
			}
		case "interface":
			if value.Type != gjson.Null {
				if value.Type != gjson.Number {
					err = errors.NewInvalidArgument()
					return false
				}
				var optionalValue int
				optionalValue = int(value.Int())
				u.interface_ = &optionalValue
			}
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	var missingFields []string
	if !seentyp {
		missingFields = append(missingFields, "type")
	}
	if len(missingFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("missingFields", missingFields))
	}
	if strict && len(unrecognizedFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields))
	}
	return nil
}

func (u *Union) Accept(v UnionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "stringExample":
		return v.VisitStringExample(*u.stringExample)
	case "set":
		return v.VisitSet(*u.set)
	case "thisFieldIsAnInteger":
		return v.VisitThisFieldIsAnInteger(*u.thisFieldIsAnInteger)
	case "alsoAnInteger":
		return v.VisitAlsoAnInteger(*u.alsoAnInteger)
	case "if":
		return v.VisitIf(*u.if_)
	case "new":
		return v.VisitNew(*u.new)
	case "interface":
		return v.VisitInterface(*u.interface_)
	}
}

type UnionVisitor interface {
	VisitStringExample(v StringExample) error
	VisitSet(v []string) error
	VisitThisFieldIsAnInteger(v int) error
	VisitAlsoAnInteger(v int) error
	VisitIf(v int) error
	VisitNew(v int) error
	VisitInterface(v int) error
	VisitUnknown(typeName string) error
}

func (u *Union) AcceptWithContext(ctx context.Context, v UnionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "stringExample":
		return v.VisitStringExampleWithContext(ctx, *u.stringExample)
	case "set":
		return v.VisitSetWithContext(ctx, *u.set)
	case "thisFieldIsAnInteger":
		return v.VisitThisFieldIsAnIntegerWithContext(ctx, *u.thisFieldIsAnInteger)
	case "alsoAnInteger":
		return v.VisitAlsoAnIntegerWithContext(ctx, *u.alsoAnInteger)
	case "if":
		return v.VisitIfWithContext(ctx, *u.if_)
	case "new":
		return v.VisitNewWithContext(ctx, *u.new)
	case "interface":
		return v.VisitInterfaceWithContext(ctx, *u.interface_)
	}
}

type UnionVisitorWithContext interface {
	VisitStringExampleWithContext(ctx context.Context, v StringExample) error
	VisitSetWithContext(ctx context.Context, v []string) error
	VisitThisFieldIsAnIntegerWithContext(ctx context.Context, v int) error
	VisitAlsoAnIntegerWithContext(ctx context.Context, v int) error
	VisitIfWithContext(ctx context.Context, v int) error
	VisitNewWithContext(ctx context.Context, v int) error
	VisitInterfaceWithContext(ctx context.Context, v int) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewUnionFromStringExample(v StringExample) Union {
	return Union{typ: "stringExample", stringExample: &v}
}

func NewUnionFromSet(v []string) Union {
	return Union{typ: "set", set: &v}
}

func NewUnionFromThisFieldIsAnInteger(v int) Union {
	return Union{typ: "thisFieldIsAnInteger", thisFieldIsAnInteger: &v}
}

func NewUnionFromAlsoAnInteger(v int) Union {
	return Union{typ: "alsoAnInteger", alsoAnInteger: &v}
}

func NewUnionFromIf(v int) Union {
	return Union{typ: "if", if_: &v}
}

func NewUnionFromNew(v int) Union {
	return Union{typ: "new", new: &v}
}

func NewUnionFromInterface(v int) Union {
	return Union{typ: "interface", interface_: &v}
}
