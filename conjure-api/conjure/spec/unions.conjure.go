// This file was generated by Conjure and should not be manually edited.

package spec

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
	werror "github.com/palantir/witchcraft-go-error"
	wparams "github.com/palantir/witchcraft-go-params"
	"github.com/tidwall/gjson"
)

type AuthType struct {
	typ    string
	header *HeaderAuthType
	cookie *CookieAuthType
}

func (u *AuthType) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %s", u.typ)
	case "header":
		return struct {
			Type   string         `json:"type"`
			Header HeaderAuthType `json:"header"`
		}{Type: "header", Header: *u.header}, nil
	case "cookie":
		return struct {
			Type   string         `json:"type"`
			Cookie CookieAuthType `json:"cookie"`
		}{Type: "cookie", Cookie: *u.cookie}, nil
	}
}

func (u AuthType) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u AuthType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

// UnmarshalJSON deserializes data, ignoring unrecognized keys.
// Prefer UnmarshalJSONString if data is already in string form to avoid an extra copy.
func (u *AuthType) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return werror.Wrap(errors.NewInvalidArgument(), "invalid json")
	}
	return u.unmarshalGJSON(gjson.ParseBytes(data), false)
}

// UnmarshalJSONString deserializes data, ignoring unrecognized keys.
func (u *AuthType) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return werror.Wrap(errors.NewInvalidArgument(), "invalid json")
	}
	return u.unmarshalGJSON(gjson.Parse(data), false)
}

// UnmarshalJSONStrict deserializes data, rejecting unrecognized keys.
// Prefer UnmarshalJSONStringStrict if data is already in string form to avoid an extra copy.
func (u *AuthType) UnmarshalJSONStrict(data []byte) error {
	if !gjson.ValidBytes(data) {
		return werror.Wrap(errors.NewInvalidArgument(), "invalid json")
	}
	return u.unmarshalGJSON(gjson.ParseBytes(data), true)
}

// UnmarshalJSONStringStrict deserializes data, rejecting unrecognized keys.
func (u *AuthType) UnmarshalJSONStringStrict(data string) error {
	if !gjson.Valid(data) {
		return werror.Wrap(errors.NewInvalidArgument(), "invalid json")
	}
	return u.unmarshalGJSON(gjson.Parse(data), true)
}

// UnmarshalYAML implements yaml.Unmarshaler. It converts the YAML to JSON, then runs UnmarshalJSON.
func (u *AuthType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	data, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return werror.Wrap(err, "failed to convert YAML to JSON")
	}
	return u.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (u *AuthType) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return werror.Wrap(errors.NewInvalidArgument(), "expected json object")
	}
	var seentyp bool
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "type":
			seentyp = true
			if value.Type != gjson.String {
				err = werror.Wrap(errors.NewInvalidArgument(), "expected json type String", werror.SafeParam("fieldType", value.Type.String()))
				return false
			}
			u.typ = value.Str
		case "header":
			if value.Type != gjson.Null {
				var optionalValue HeaderAuthType
				u.header = &optionalValue
			}
		case "cookie":
			if value.Type != gjson.Null {
				var optionalValue CookieAuthType
				if strict {
					err = optionalValue.UnmarshalJSONStringStrict(value.Raw)
				} else {
					err = optionalValue.UnmarshalJSONString(value.Raw)
				}
				u.cookie = &optionalValue
			}
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	var missingFields []string
	if !seentyp {
		missingFields = append(missingFields, "type")
	}
	if len(missingFields) > 0 {
		return werror.Wrap(errors.NewInvalidArgument(wparams.NewSafeParam("missingFields", missingFields)), "missing json fields")
	}
	if strict && len(unrecognizedFields) > 0 {
		return werror.Wrap(errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields)), "unrecognized json fields")
	}
	return nil
}

func (u *AuthType) Accept(v AuthTypeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "header":
		return v.VisitHeader(*u.header)
	case "cookie":
		return v.VisitCookie(*u.cookie)
	}
}

type AuthTypeVisitor interface {
	VisitHeader(v HeaderAuthType) error
	VisitCookie(v CookieAuthType) error
	VisitUnknown(typeName string) error
}

func (u *AuthType) AcceptWithContext(ctx context.Context, v AuthTypeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "header":
		return v.VisitHeaderWithContext(ctx, *u.header)
	case "cookie":
		return v.VisitCookieWithContext(ctx, *u.cookie)
	}
}

type AuthTypeVisitorWithContext interface {
	VisitHeaderWithContext(ctx context.Context, v HeaderAuthType) error
	VisitCookieWithContext(ctx context.Context, v CookieAuthType) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewAuthTypeFromHeader(v HeaderAuthType) AuthType {
	return AuthType{typ: "header", header: &v}
}

func NewAuthTypeFromCookie(v CookieAuthType) AuthType {
	return AuthType{typ: "cookie", cookie: &v}
}

type ParameterType struct {
	typ    string
	body   *BodyParameterType
	header *HeaderParameterType
	path   *PathParameterType
	query  *QueryParameterType
}

func (u *ParameterType) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %s", u.typ)
	case "body":
		return struct {
			Type string            `json:"type"`
			Body BodyParameterType `json:"body"`
		}{Type: "body", Body: *u.body}, nil
	case "header":
		return struct {
			Type   string              `json:"type"`
			Header HeaderParameterType `json:"header"`
		}{Type: "header", Header: *u.header}, nil
	case "path":
		return struct {
			Type string            `json:"type"`
			Path PathParameterType `json:"path"`
		}{Type: "path", Path: *u.path}, nil
	case "query":
		return struct {
			Type  string             `json:"type"`
			Query QueryParameterType `json:"query"`
		}{Type: "query", Query: *u.query}, nil
	}
}

func (u ParameterType) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u ParameterType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

// UnmarshalJSON deserializes data, ignoring unrecognized keys.
// Prefer UnmarshalJSONString if data is already in string form to avoid an extra copy.
func (u *ParameterType) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return werror.Wrap(errors.NewInvalidArgument(), "invalid json")
	}
	return u.unmarshalGJSON(gjson.ParseBytes(data), false)
}

// UnmarshalJSONString deserializes data, ignoring unrecognized keys.
func (u *ParameterType) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return werror.Wrap(errors.NewInvalidArgument(), "invalid json")
	}
	return u.unmarshalGJSON(gjson.Parse(data), false)
}

// UnmarshalJSONStrict deserializes data, rejecting unrecognized keys.
// Prefer UnmarshalJSONStringStrict if data is already in string form to avoid an extra copy.
func (u *ParameterType) UnmarshalJSONStrict(data []byte) error {
	if !gjson.ValidBytes(data) {
		return werror.Wrap(errors.NewInvalidArgument(), "invalid json")
	}
	return u.unmarshalGJSON(gjson.ParseBytes(data), true)
}

// UnmarshalJSONStringStrict deserializes data, rejecting unrecognized keys.
func (u *ParameterType) UnmarshalJSONStringStrict(data string) error {
	if !gjson.Valid(data) {
		return werror.Wrap(errors.NewInvalidArgument(), "invalid json")
	}
	return u.unmarshalGJSON(gjson.Parse(data), true)
}

// UnmarshalYAML implements yaml.Unmarshaler. It converts the YAML to JSON, then runs UnmarshalJSON.
func (u *ParameterType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	data, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return werror.Wrap(err, "failed to convert YAML to JSON")
	}
	return u.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (u *ParameterType) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return werror.Wrap(errors.NewInvalidArgument(), "expected json object")
	}
	var seentyp bool
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "type":
			seentyp = true
			if value.Type != gjson.String {
				err = werror.Wrap(errors.NewInvalidArgument(), "expected json type String", werror.SafeParam("fieldType", value.Type.String()))
				return false
			}
			u.typ = value.Str
		case "body":
			if value.Type != gjson.Null {
				var optionalValue BodyParameterType
				u.body = &optionalValue
			}
		case "header":
			if value.Type != gjson.Null {
				var optionalValue HeaderParameterType
				if strict {
					err = optionalValue.UnmarshalJSONStringStrict(value.Raw)
				} else {
					err = optionalValue.UnmarshalJSONString(value.Raw)
				}
				u.header = &optionalValue
			}
		case "path":
			if value.Type != gjson.Null {
				var optionalValue PathParameterType
				u.path = &optionalValue
			}
		case "query":
			if value.Type != gjson.Null {
				var optionalValue QueryParameterType
				if strict {
					err = optionalValue.UnmarshalJSONStringStrict(value.Raw)
				} else {
					err = optionalValue.UnmarshalJSONString(value.Raw)
				}
				u.query = &optionalValue
			}
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	var missingFields []string
	if !seentyp {
		missingFields = append(missingFields, "type")
	}
	if len(missingFields) > 0 {
		return werror.Wrap(errors.NewInvalidArgument(wparams.NewSafeParam("missingFields", missingFields)), "missing json fields")
	}
	if strict && len(unrecognizedFields) > 0 {
		return werror.Wrap(errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields)), "unrecognized json fields")
	}
	return nil
}

func (u *ParameterType) Accept(v ParameterTypeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "body":
		return v.VisitBody(*u.body)
	case "header":
		return v.VisitHeader(*u.header)
	case "path":
		return v.VisitPath(*u.path)
	case "query":
		return v.VisitQuery(*u.query)
	}
}

type ParameterTypeVisitor interface {
	VisitBody(v BodyParameterType) error
	VisitHeader(v HeaderParameterType) error
	VisitPath(v PathParameterType) error
	VisitQuery(v QueryParameterType) error
	VisitUnknown(typeName string) error
}

func (u *ParameterType) AcceptWithContext(ctx context.Context, v ParameterTypeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "body":
		return v.VisitBodyWithContext(ctx, *u.body)
	case "header":
		return v.VisitHeaderWithContext(ctx, *u.header)
	case "path":
		return v.VisitPathWithContext(ctx, *u.path)
	case "query":
		return v.VisitQueryWithContext(ctx, *u.query)
	}
}

type ParameterTypeVisitorWithContext interface {
	VisitBodyWithContext(ctx context.Context, v BodyParameterType) error
	VisitHeaderWithContext(ctx context.Context, v HeaderParameterType) error
	VisitPathWithContext(ctx context.Context, v PathParameterType) error
	VisitQueryWithContext(ctx context.Context, v QueryParameterType) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewParameterTypeFromBody(v BodyParameterType) ParameterType {
	return ParameterType{typ: "body", body: &v}
}

func NewParameterTypeFromHeader(v HeaderParameterType) ParameterType {
	return ParameterType{typ: "header", header: &v}
}

func NewParameterTypeFromPath(v PathParameterType) ParameterType {
	return ParameterType{typ: "path", path: &v}
}

func NewParameterTypeFromQuery(v QueryParameterType) ParameterType {
	return ParameterType{typ: "query", query: &v}
}

type Type struct {
	typ       string
	primitive *PrimitiveType
	optional  *OptionalType
	list      *ListType
	set       *SetType
	map_      *MapType
	reference *TypeName
	external  *ExternalReference
}

func (u *Type) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %s", u.typ)
	case "primitive":
		return struct {
			Type      string        `json:"type"`
			Primitive PrimitiveType `json:"primitive"`
		}{Type: "primitive", Primitive: *u.primitive}, nil
	case "optional":
		return struct {
			Type     string       `json:"type"`
			Optional OptionalType `json:"optional"`
		}{Type: "optional", Optional: *u.optional}, nil
	case "list":
		return struct {
			Type string   `json:"type"`
			List ListType `json:"list"`
		}{Type: "list", List: *u.list}, nil
	case "set":
		return struct {
			Type string  `json:"type"`
			Set  SetType `json:"set"`
		}{Type: "set", Set: *u.set}, nil
	case "map":
		return struct {
			Type string  `json:"type"`
			Map  MapType `json:"map"`
		}{Type: "map", Map: *u.map_}, nil
	case "reference":
		return struct {
			Type      string   `json:"type"`
			Reference TypeName `json:"reference"`
		}{Type: "reference", Reference: *u.reference}, nil
	case "external":
		return struct {
			Type     string            `json:"type"`
			External ExternalReference `json:"external"`
		}{Type: "external", External: *u.external}, nil
	}
}

func (u Type) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u Type) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

// UnmarshalJSON deserializes data, ignoring unrecognized keys.
// Prefer UnmarshalJSONString if data is already in string form to avoid an extra copy.
func (u *Type) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return werror.Wrap(errors.NewInvalidArgument(), "invalid json")
	}
	return u.unmarshalGJSON(gjson.ParseBytes(data), false)
}

// UnmarshalJSONString deserializes data, ignoring unrecognized keys.
func (u *Type) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return werror.Wrap(errors.NewInvalidArgument(), "invalid json")
	}
	return u.unmarshalGJSON(gjson.Parse(data), false)
}

// UnmarshalJSONStrict deserializes data, rejecting unrecognized keys.
// Prefer UnmarshalJSONStringStrict if data is already in string form to avoid an extra copy.
func (u *Type) UnmarshalJSONStrict(data []byte) error {
	if !gjson.ValidBytes(data) {
		return werror.Wrap(errors.NewInvalidArgument(), "invalid json")
	}
	return u.unmarshalGJSON(gjson.ParseBytes(data), true)
}

// UnmarshalJSONStringStrict deserializes data, rejecting unrecognized keys.
func (u *Type) UnmarshalJSONStringStrict(data string) error {
	if !gjson.Valid(data) {
		return werror.Wrap(errors.NewInvalidArgument(), "invalid json")
	}
	return u.unmarshalGJSON(gjson.Parse(data), true)
}

// UnmarshalYAML implements yaml.Unmarshaler. It converts the YAML to JSON, then runs UnmarshalJSON.
func (u *Type) UnmarshalYAML(unmarshal func(interface{}) error) error {
	data, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return werror.Wrap(err, "failed to convert YAML to JSON")
	}
	return u.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (u *Type) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return werror.Wrap(errors.NewInvalidArgument(), "expected json object")
	}
	var seentyp bool
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "type":
			seentyp = true
			if value.Type != gjson.String {
				err = werror.Wrap(errors.NewInvalidArgument(), "expected json type String", werror.SafeParam("fieldType", value.Type.String()))
				return false
			}
			u.typ = value.Str
		case "primitive":
			if value.Type != gjson.Null {
				if value.Type != gjson.String {
					err = werror.Wrap(errors.NewInvalidArgument(), "expected json type String", werror.SafeParam("fieldType", value.Type.String()))
					return false
				}
				var optionalValue PrimitiveType
				err = optionalValue.UnmarshalText([]byte(value.Str))
				u.primitive = &optionalValue
			}
		case "optional":
			if value.Type != gjson.Null {
				var optionalValue OptionalType
				if strict {
					err = optionalValue.UnmarshalJSONStringStrict(value.Raw)
				} else {
					err = optionalValue.UnmarshalJSONString(value.Raw)
				}
				u.optional = &optionalValue
			}
		case "list":
			if value.Type != gjson.Null {
				var optionalValue ListType
				if strict {
					err = optionalValue.UnmarshalJSONStringStrict(value.Raw)
				} else {
					err = optionalValue.UnmarshalJSONString(value.Raw)
				}
				u.list = &optionalValue
			}
		case "set":
			if value.Type != gjson.Null {
				var optionalValue SetType
				if strict {
					err = optionalValue.UnmarshalJSONStringStrict(value.Raw)
				} else {
					err = optionalValue.UnmarshalJSONString(value.Raw)
				}
				u.set = &optionalValue
			}
		case "map":
			if value.Type != gjson.Null {
				var optionalValue MapType
				if strict {
					err = optionalValue.UnmarshalJSONStringStrict(value.Raw)
				} else {
					err = optionalValue.UnmarshalJSONString(value.Raw)
				}
				u.map_ = &optionalValue
			}
		case "reference":
			if value.Type != gjson.Null {
				var optionalValue TypeName
				if strict {
					err = optionalValue.UnmarshalJSONStringStrict(value.Raw)
				} else {
					err = optionalValue.UnmarshalJSONString(value.Raw)
				}
				u.reference = &optionalValue
			}
		case "external":
			if value.Type != gjson.Null {
				var optionalValue ExternalReference
				if strict {
					err = optionalValue.UnmarshalJSONStringStrict(value.Raw)
				} else {
					err = optionalValue.UnmarshalJSONString(value.Raw)
				}
				u.external = &optionalValue
			}
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	var missingFields []string
	if !seentyp {
		missingFields = append(missingFields, "type")
	}
	if len(missingFields) > 0 {
		return werror.Wrap(errors.NewInvalidArgument(wparams.NewSafeParam("missingFields", missingFields)), "missing json fields")
	}
	if strict && len(unrecognizedFields) > 0 {
		return werror.Wrap(errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields)), "unrecognized json fields")
	}
	return nil
}

func (u *Type) Accept(v TypeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "primitive":
		return v.VisitPrimitive(*u.primitive)
	case "optional":
		return v.VisitOptional(*u.optional)
	case "list":
		return v.VisitList(*u.list)
	case "set":
		return v.VisitSet(*u.set)
	case "map":
		return v.VisitMap(*u.map_)
	case "reference":
		return v.VisitReference(*u.reference)
	case "external":
		return v.VisitExternal(*u.external)
	}
}

type TypeVisitor interface {
	VisitPrimitive(v PrimitiveType) error
	VisitOptional(v OptionalType) error
	VisitList(v ListType) error
	VisitSet(v SetType) error
	VisitMap(v MapType) error
	VisitReference(v TypeName) error
	VisitExternal(v ExternalReference) error
	VisitUnknown(typeName string) error
}

func (u *Type) AcceptWithContext(ctx context.Context, v TypeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "primitive":
		return v.VisitPrimitiveWithContext(ctx, *u.primitive)
	case "optional":
		return v.VisitOptionalWithContext(ctx, *u.optional)
	case "list":
		return v.VisitListWithContext(ctx, *u.list)
	case "set":
		return v.VisitSetWithContext(ctx, *u.set)
	case "map":
		return v.VisitMapWithContext(ctx, *u.map_)
	case "reference":
		return v.VisitReferenceWithContext(ctx, *u.reference)
	case "external":
		return v.VisitExternalWithContext(ctx, *u.external)
	}
}

type TypeVisitorWithContext interface {
	VisitPrimitiveWithContext(ctx context.Context, v PrimitiveType) error
	VisitOptionalWithContext(ctx context.Context, v OptionalType) error
	VisitListWithContext(ctx context.Context, v ListType) error
	VisitSetWithContext(ctx context.Context, v SetType) error
	VisitMapWithContext(ctx context.Context, v MapType) error
	VisitReferenceWithContext(ctx context.Context, v TypeName) error
	VisitExternalWithContext(ctx context.Context, v ExternalReference) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewTypeFromPrimitive(v PrimitiveType) Type {
	return Type{typ: "primitive", primitive: &v}
}

func NewTypeFromOptional(v OptionalType) Type {
	return Type{typ: "optional", optional: &v}
}

func NewTypeFromList(v ListType) Type {
	return Type{typ: "list", list: &v}
}

func NewTypeFromSet(v SetType) Type {
	return Type{typ: "set", set: &v}
}

func NewTypeFromMap(v MapType) Type {
	return Type{typ: "map", map_: &v}
}

func NewTypeFromReference(v TypeName) Type {
	return Type{typ: "reference", reference: &v}
}

func NewTypeFromExternal(v ExternalReference) Type {
	return Type{typ: "external", external: &v}
}

type TypeDefinition struct {
	typ    string
	alias  *AliasDefinition
	enum   *EnumDefinition
	object *ObjectDefinition
	union  *UnionDefinition
}

func (u *TypeDefinition) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %s", u.typ)
	case "alias":
		return struct {
			Type  string          `json:"type"`
			Alias AliasDefinition `json:"alias"`
		}{Type: "alias", Alias: *u.alias}, nil
	case "enum":
		return struct {
			Type string         `json:"type"`
			Enum EnumDefinition `json:"enum"`
		}{Type: "enum", Enum: *u.enum}, nil
	case "object":
		return struct {
			Type   string           `json:"type"`
			Object ObjectDefinition `json:"object"`
		}{Type: "object", Object: *u.object}, nil
	case "union":
		return struct {
			Type  string          `json:"type"`
			Union UnionDefinition `json:"union"`
		}{Type: "union", Union: *u.union}, nil
	}
}

func (u TypeDefinition) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u TypeDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

// UnmarshalJSON deserializes data, ignoring unrecognized keys.
// Prefer UnmarshalJSONString if data is already in string form to avoid an extra copy.
func (u *TypeDefinition) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return werror.Wrap(errors.NewInvalidArgument(), "invalid json")
	}
	return u.unmarshalGJSON(gjson.ParseBytes(data), false)
}

// UnmarshalJSONString deserializes data, ignoring unrecognized keys.
func (u *TypeDefinition) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return werror.Wrap(errors.NewInvalidArgument(), "invalid json")
	}
	return u.unmarshalGJSON(gjson.Parse(data), false)
}

// UnmarshalJSONStrict deserializes data, rejecting unrecognized keys.
// Prefer UnmarshalJSONStringStrict if data is already in string form to avoid an extra copy.
func (u *TypeDefinition) UnmarshalJSONStrict(data []byte) error {
	if !gjson.ValidBytes(data) {
		return werror.Wrap(errors.NewInvalidArgument(), "invalid json")
	}
	return u.unmarshalGJSON(gjson.ParseBytes(data), true)
}

// UnmarshalJSONStringStrict deserializes data, rejecting unrecognized keys.
func (u *TypeDefinition) UnmarshalJSONStringStrict(data string) error {
	if !gjson.Valid(data) {
		return werror.Wrap(errors.NewInvalidArgument(), "invalid json")
	}
	return u.unmarshalGJSON(gjson.Parse(data), true)
}

// UnmarshalYAML implements yaml.Unmarshaler. It converts the YAML to JSON, then runs UnmarshalJSON.
func (u *TypeDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	data, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return werror.Wrap(err, "failed to convert YAML to JSON")
	}
	return u.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (u *TypeDefinition) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return werror.Wrap(errors.NewInvalidArgument(), "expected json object")
	}
	var seentyp bool
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "type":
			seentyp = true
			if value.Type != gjson.String {
				err = werror.Wrap(errors.NewInvalidArgument(), "expected json type String", werror.SafeParam("fieldType", value.Type.String()))
				return false
			}
			u.typ = value.Str
		case "alias":
			if value.Type != gjson.Null {
				var optionalValue AliasDefinition
				if strict {
					err = optionalValue.UnmarshalJSONStringStrict(value.Raw)
				} else {
					err = optionalValue.UnmarshalJSONString(value.Raw)
				}
				u.alias = &optionalValue
			}
		case "enum":
			if value.Type != gjson.Null {
				var optionalValue EnumDefinition
				if strict {
					err = optionalValue.UnmarshalJSONStringStrict(value.Raw)
				} else {
					err = optionalValue.UnmarshalJSONString(value.Raw)
				}
				u.enum = &optionalValue
			}
		case "object":
			if value.Type != gjson.Null {
				var optionalValue ObjectDefinition
				if strict {
					err = optionalValue.UnmarshalJSONStringStrict(value.Raw)
				} else {
					err = optionalValue.UnmarshalJSONString(value.Raw)
				}
				u.object = &optionalValue
			}
		case "union":
			if value.Type != gjson.Null {
				var optionalValue UnionDefinition
				if strict {
					err = optionalValue.UnmarshalJSONStringStrict(value.Raw)
				} else {
					err = optionalValue.UnmarshalJSONString(value.Raw)
				}
				u.union = &optionalValue
			}
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	var missingFields []string
	if !seentyp {
		missingFields = append(missingFields, "type")
	}
	if len(missingFields) > 0 {
		return werror.Wrap(errors.NewInvalidArgument(wparams.NewSafeParam("missingFields", missingFields)), "missing json fields")
	}
	if strict && len(unrecognizedFields) > 0 {
		return werror.Wrap(errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields)), "unrecognized json fields")
	}
	return nil
}

func (u *TypeDefinition) Accept(v TypeDefinitionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "alias":
		return v.VisitAlias(*u.alias)
	case "enum":
		return v.VisitEnum(*u.enum)
	case "object":
		return v.VisitObject(*u.object)
	case "union":
		return v.VisitUnion(*u.union)
	}
}

type TypeDefinitionVisitor interface {
	VisitAlias(v AliasDefinition) error
	VisitEnum(v EnumDefinition) error
	VisitObject(v ObjectDefinition) error
	VisitUnion(v UnionDefinition) error
	VisitUnknown(typeName string) error
}

func (u *TypeDefinition) AcceptWithContext(ctx context.Context, v TypeDefinitionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "alias":
		return v.VisitAliasWithContext(ctx, *u.alias)
	case "enum":
		return v.VisitEnumWithContext(ctx, *u.enum)
	case "object":
		return v.VisitObjectWithContext(ctx, *u.object)
	case "union":
		return v.VisitUnionWithContext(ctx, *u.union)
	}
}

type TypeDefinitionVisitorWithContext interface {
	VisitAliasWithContext(ctx context.Context, v AliasDefinition) error
	VisitEnumWithContext(ctx context.Context, v EnumDefinition) error
	VisitObjectWithContext(ctx context.Context, v ObjectDefinition) error
	VisitUnionWithContext(ctx context.Context, v UnionDefinition) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewTypeDefinitionFromAlias(v AliasDefinition) TypeDefinition {
	return TypeDefinition{typ: "alias", alias: &v}
}

func NewTypeDefinitionFromEnum(v EnumDefinition) TypeDefinition {
	return TypeDefinition{typ: "enum", enum: &v}
}

func NewTypeDefinitionFromObject(v ObjectDefinition) TypeDefinition {
	return TypeDefinition{typ: "object", object: &v}
}

func NewTypeDefinitionFromUnion(v UnionDefinition) TypeDefinition {
	return TypeDefinition{typ: "union", union: &v}
}
