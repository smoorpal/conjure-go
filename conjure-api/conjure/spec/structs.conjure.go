// This file was generated by Conjure and should not be manually edited.

package spec

import (
	"github.com/palantir/conjure-go-runtime/conjure-go-contract/errors"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
	"github.com/tidwall/gjson"
)

type AliasDefinition struct {
	TypeName TypeName
	Alias    Type
	Docs     *Documentation
}

func (o AliasDefinition) MarshalJSON() ([]byte, error) {
	type AliasDefinitionAlias AliasDefinition
	return safejson.Marshal(AliasDefinitionAlias(o))
}

func (o *AliasDefinition) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	value := gjson.ParseBytes(data)
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		switch key.Str {
		case "typeName":
			err = o.TypeName.UnmarshalJSON([]byte(value.Raw))
		case "alias":
			err = o.Alias.UnmarshalJSON([]byte(value.Raw))
		case "docs":
			if value.Type != gjson.Null {
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var v Documentation
				v = Documentation(value.Str)
				o.Docs = &v
			}
		}
		return err == nil
	})
	return err
}

func (o AliasDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := o.MarshalJSON()
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AliasDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}

type ArgumentDefinition struct {
	ArgName   ArgumentName
	Type      Type
	ParamType ParameterType
	Docs      *Documentation
	Markers   []Type
	Tags      []string
}

func (o ArgumentDefinition) MarshalJSON() ([]byte, error) {
	if o.Markers == nil {
		o.Markers = make([]Type, 0)
	}
	if o.Tags == nil {
		o.Tags = make([]string, 0)
	}
	type ArgumentDefinitionAlias ArgumentDefinition
	return safejson.Marshal(ArgumentDefinitionAlias(o))
}

func (o *ArgumentDefinition) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	value := gjson.ParseBytes(data)
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		switch key.Str {
		case "argName":
			if value.Type != gjson.String {
				err = errors.NewInvalidArgument()
				return false
			}
			o.ArgName = ArgumentName(value.Str)
		case "type":
			err = o.Type.UnmarshalJSON([]byte(value.Raw))
		case "paramType":
			err = o.ParamType.UnmarshalJSON([]byte(value.Raw))
		case "docs":
			if value.Type != gjson.Null {
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var v Documentation
				v = Documentation(value.Str)
				o.Docs = &v
			}
		case "markers":
			if !value.IsArray() {
				err = errors.NewInvalidArgument()
				return false
			}
			value.ForEach(func(_, value gjson.Result) bool {
				var v Type
				err = v.UnmarshalJSON([]byte(value.Raw))
				o.Markers = append(o.Markers, v)
				return err == nil
			})
		case "tags":
			if !value.IsArray() {
				err = errors.NewInvalidArgument()
				return false
			}
			value.ForEach(func(_, value gjson.Result) bool {
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var v string
				v = value.Str
				o.Tags = append(o.Tags, v)
				return err == nil
			})
		}
		return err == nil
	})
	return err
}

func (o ArgumentDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := o.MarshalJSON()
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ArgumentDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}

type BodyParameterType struct {
}

type ConjureDefinition struct {
	Version    int
	Errors     []ErrorDefinition
	Types      []TypeDefinition
	Services   []ServiceDefinition
	Extensions map[string]interface{}
}

func (o ConjureDefinition) MarshalJSON() ([]byte, error) {
	if o.Errors == nil {
		o.Errors = make([]ErrorDefinition, 0)
	}
	if o.Types == nil {
		o.Types = make([]TypeDefinition, 0)
	}
	if o.Services == nil {
		o.Services = make([]ServiceDefinition, 0)
	}
	if o.Extensions == nil {
		o.Extensions = make(map[string]interface{}, 0)
	}
	type ConjureDefinitionAlias ConjureDefinition
	return safejson.Marshal(ConjureDefinitionAlias(o))
}

func (o *ConjureDefinition) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	value := gjson.ParseBytes(data)
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		switch key.Str {
		case "version":
			if value.Type != gjson.Number {
				err = errors.NewInvalidArgument()
				return false
			}
			o.Version = int(value.Int())
		case "errors":
			if !value.IsArray() {
				err = errors.NewInvalidArgument()
				return false
			}
			value.ForEach(func(_, value gjson.Result) bool {
				var v ErrorDefinition
				err = v.UnmarshalJSON([]byte(value.Raw))
				o.Errors = append(o.Errors, v)
				return err == nil
			})
		case "types":
			if !value.IsArray() {
				err = errors.NewInvalidArgument()
				return false
			}
			value.ForEach(func(_, value gjson.Result) bool {
				var v TypeDefinition
				err = v.UnmarshalJSON([]byte(value.Raw))
				o.Types = append(o.Types, v)
				return err == nil
			})
		case "services":
			if !value.IsArray() {
				err = errors.NewInvalidArgument()
				return false
			}
			value.ForEach(func(_, value gjson.Result) bool {
				var v ServiceDefinition
				err = v.UnmarshalJSON([]byte(value.Raw))
				o.Services = append(o.Services, v)
				return err == nil
			})
		case "extensions":
			if !value.IsObject() {
				err = errors.NewInvalidArgument()
				return false
			}
			if o.Extensions == nil {
				o.Extensions = make(map[string]interface{})
			}
			value.ForEach(func(key, value gjson.Result) bool {
				if key.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var destKey string
				destKey = key.Str
				if value.Type != gjson.JSON && value.Type != gjson.String && value.Type != gjson.Number && value.Type != gjson.True && value.Type != gjson.False {
					err = errors.NewInvalidArgument()
					return false
				}
				var destVal interface{}
				destVal = value.Value()
				o.Extensions[destKey] = destVal
				return err == nil
			})
		}
		return err == nil
	})
	return err
}

func (o ConjureDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := o.MarshalJSON()
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ConjureDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}

type CookieAuthType struct {
	CookieName string
}

func (o CookieAuthType) MarshalJSON() ([]byte, error) {
	type CookieAuthTypeAlias CookieAuthType
	return safejson.Marshal(CookieAuthTypeAlias(o))
}

func (o *CookieAuthType) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	value := gjson.ParseBytes(data)
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		switch key.Str {
		case "cookieName":
			if value.Type != gjson.String {
				err = errors.NewInvalidArgument()
				return false
			}
			o.CookieName = value.Str
		}
		return err == nil
	})
	return err
}

func (o CookieAuthType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := o.MarshalJSON()
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CookieAuthType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}

type EndpointDefinition struct {
	EndpointName EndpointName
	HttpMethod   HttpMethod
	HttpPath     HttpPath
	Auth         *AuthType
	Args         []ArgumentDefinition
	Returns      *Type
	Docs         *Documentation
	Deprecated   *Documentation
	Markers      []Type
	Tags         []string
}

func (o EndpointDefinition) MarshalJSON() ([]byte, error) {
	if o.Args == nil {
		o.Args = make([]ArgumentDefinition, 0)
	}
	if o.Markers == nil {
		o.Markers = make([]Type, 0)
	}
	if o.Tags == nil {
		o.Tags = make([]string, 0)
	}
	type EndpointDefinitionAlias EndpointDefinition
	return safejson.Marshal(EndpointDefinitionAlias(o))
}

func (o *EndpointDefinition) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	value := gjson.ParseBytes(data)
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		switch key.Str {
		case "endpointName":
			if value.Type != gjson.String {
				err = errors.NewInvalidArgument()
				return false
			}
			o.EndpointName = EndpointName(value.Str)
		case "httpMethod":
			if value.Type != gjson.String {
				err = errors.NewInvalidArgument()
				return false
			}
			err = o.HttpMethod.UnmarshalText([]byte(value.Str))
		case "httpPath":
			if value.Type != gjson.String {
				err = errors.NewInvalidArgument()
				return false
			}
			o.HttpPath = HttpPath(value.Str)
		case "auth":
			if value.Type != gjson.Null {
				var v AuthType
				err = v.UnmarshalJSON([]byte(value.Raw))
				o.Auth = &v
			}
		case "args":
			if !value.IsArray() {
				err = errors.NewInvalidArgument()
				return false
			}
			value.ForEach(func(_, value gjson.Result) bool {
				var v ArgumentDefinition
				err = v.UnmarshalJSON([]byte(value.Raw))
				o.Args = append(o.Args, v)
				return err == nil
			})
		case "returns":
			if value.Type != gjson.Null {
				var v Type
				err = v.UnmarshalJSON([]byte(value.Raw))
				o.Returns = &v
			}
		case "docs":
			if value.Type != gjson.Null {
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var v Documentation
				v = Documentation(value.Str)
				o.Docs = &v
			}
		case "deprecated":
			if value.Type != gjson.Null {
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var v Documentation
				v = Documentation(value.Str)
				o.Deprecated = &v
			}
		case "markers":
			if !value.IsArray() {
				err = errors.NewInvalidArgument()
				return false
			}
			value.ForEach(func(_, value gjson.Result) bool {
				var v Type
				err = v.UnmarshalJSON([]byte(value.Raw))
				o.Markers = append(o.Markers, v)
				return err == nil
			})
		case "tags":
			if !value.IsArray() {
				err = errors.NewInvalidArgument()
				return false
			}
			value.ForEach(func(_, value gjson.Result) bool {
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var v string
				v = value.Str
				o.Tags = append(o.Tags, v)
				return err == nil
			})
		}
		return err == nil
	})
	return err
}

func (o EndpointDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := o.MarshalJSON()
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EndpointDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}

type EnumDefinition struct {
	TypeName TypeName
	Values   []EnumValueDefinition
	Docs     *Documentation
}

func (o EnumDefinition) MarshalJSON() ([]byte, error) {
	if o.Values == nil {
		o.Values = make([]EnumValueDefinition, 0)
	}
	type EnumDefinitionAlias EnumDefinition
	return safejson.Marshal(EnumDefinitionAlias(o))
}

func (o *EnumDefinition) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	value := gjson.ParseBytes(data)
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		switch key.Str {
		case "typeName":
			err = o.TypeName.UnmarshalJSON([]byte(value.Raw))
		case "values":
			if !value.IsArray() {
				err = errors.NewInvalidArgument()
				return false
			}
			value.ForEach(func(_, value gjson.Result) bool {
				var v EnumValueDefinition
				err = v.UnmarshalJSON([]byte(value.Raw))
				o.Values = append(o.Values, v)
				return err == nil
			})
		case "docs":
			if value.Type != gjson.Null {
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var v Documentation
				v = Documentation(value.Str)
				o.Docs = &v
			}
		}
		return err == nil
	})
	return err
}

func (o EnumDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := o.MarshalJSON()
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnumDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}

type EnumValueDefinition struct {
	Value      string
	Docs       *Documentation
	Deprecated *Documentation
}

func (o EnumValueDefinition) MarshalJSON() ([]byte, error) {
	type EnumValueDefinitionAlias EnumValueDefinition
	return safejson.Marshal(EnumValueDefinitionAlias(o))
}

func (o *EnumValueDefinition) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	value := gjson.ParseBytes(data)
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		switch key.Str {
		case "value":
			if value.Type != gjson.String {
				err = errors.NewInvalidArgument()
				return false
			}
			o.Value = value.Str
		case "docs":
			if value.Type != gjson.Null {
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var v Documentation
				v = Documentation(value.Str)
				o.Docs = &v
			}
		case "deprecated":
			if value.Type != gjson.Null {
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var v Documentation
				v = Documentation(value.Str)
				o.Deprecated = &v
			}
		}
		return err == nil
	})
	return err
}

func (o EnumValueDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := o.MarshalJSON()
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnumValueDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}

type ErrorDefinition struct {
	ErrorName  TypeName
	Docs       *Documentation
	Namespace  ErrorNamespace
	Code       ErrorCode
	SafeArgs   []FieldDefinition
	UnsafeArgs []FieldDefinition
}

func (o ErrorDefinition) MarshalJSON() ([]byte, error) {
	if o.SafeArgs == nil {
		o.SafeArgs = make([]FieldDefinition, 0)
	}
	if o.UnsafeArgs == nil {
		o.UnsafeArgs = make([]FieldDefinition, 0)
	}
	type ErrorDefinitionAlias ErrorDefinition
	return safejson.Marshal(ErrorDefinitionAlias(o))
}

func (o *ErrorDefinition) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	value := gjson.ParseBytes(data)
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		switch key.Str {
		case "errorName":
			err = o.ErrorName.UnmarshalJSON([]byte(value.Raw))
		case "docs":
			if value.Type != gjson.Null {
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var v Documentation
				v = Documentation(value.Str)
				o.Docs = &v
			}
		case "namespace":
			if value.Type != gjson.String {
				err = errors.NewInvalidArgument()
				return false
			}
			o.Namespace = ErrorNamespace(value.Str)
		case "code":
			if value.Type != gjson.String {
				err = errors.NewInvalidArgument()
				return false
			}
			err = o.Code.UnmarshalText([]byte(value.Str))
		case "safeArgs":
			if !value.IsArray() {
				err = errors.NewInvalidArgument()
				return false
			}
			value.ForEach(func(_, value gjson.Result) bool {
				var v FieldDefinition
				err = v.UnmarshalJSON([]byte(value.Raw))
				o.SafeArgs = append(o.SafeArgs, v)
				return err == nil
			})
		case "unsafeArgs":
			if !value.IsArray() {
				err = errors.NewInvalidArgument()
				return false
			}
			value.ForEach(func(_, value gjson.Result) bool {
				var v FieldDefinition
				err = v.UnmarshalJSON([]byte(value.Raw))
				o.UnsafeArgs = append(o.UnsafeArgs, v)
				return err == nil
			})
		}
		return err == nil
	})
	return err
}

func (o ErrorDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := o.MarshalJSON()
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ErrorDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}

type ExternalReference struct {
	// An identifier for a non-Conjure type which is already defined in a different language (e.g. Java).
	ExternalReference TypeName
	// Other language generators may use the provided fallback if the non-Conjure type is not available. The ANY PrimitiveType is permissible for all external types, but a more specific definition is preferable.
	Fallback Type
}

func (o ExternalReference) MarshalJSON() ([]byte, error) {
	type ExternalReferenceAlias ExternalReference
	return safejson.Marshal(ExternalReferenceAlias(o))
}

func (o *ExternalReference) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	value := gjson.ParseBytes(data)
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		switch key.Str {
		case "externalReference":
			err = o.ExternalReference.UnmarshalJSON([]byte(value.Raw))
		case "fallback":
			err = o.Fallback.UnmarshalJSON([]byte(value.Raw))
		}
		return err == nil
	})
	return err
}

func (o ExternalReference) MarshalYAML() (interface{}, error) {
	jsonBytes, err := o.MarshalJSON()
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ExternalReference) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}

type FieldDefinition struct {
	FieldName  FieldName
	Type       Type
	Docs       *Documentation
	Deprecated *Documentation
}

func (o FieldDefinition) MarshalJSON() ([]byte, error) {
	type FieldDefinitionAlias FieldDefinition
	return safejson.Marshal(FieldDefinitionAlias(o))
}

func (o *FieldDefinition) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	value := gjson.ParseBytes(data)
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		switch key.Str {
		case "fieldName":
			if value.Type != gjson.String {
				err = errors.NewInvalidArgument()
				return false
			}
			o.FieldName = FieldName(value.Str)
		case "type":
			err = o.Type.UnmarshalJSON([]byte(value.Raw))
		case "docs":
			if value.Type != gjson.Null {
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var v Documentation
				v = Documentation(value.Str)
				o.Docs = &v
			}
		case "deprecated":
			if value.Type != gjson.Null {
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var v Documentation
				v = Documentation(value.Str)
				o.Deprecated = &v
			}
		}
		return err == nil
	})
	return err
}

func (o FieldDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := o.MarshalJSON()
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *FieldDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}

type HeaderAuthType struct {
}

type HeaderParameterType struct {
	ParamId ParameterId
}

func (o HeaderParameterType) MarshalJSON() ([]byte, error) {
	type HeaderParameterTypeAlias HeaderParameterType
	return safejson.Marshal(HeaderParameterTypeAlias(o))
}

func (o *HeaderParameterType) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	value := gjson.ParseBytes(data)
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		switch key.Str {
		case "paramId":
			if value.Type != gjson.String {
				err = errors.NewInvalidArgument()
				return false
			}
			o.ParamId = ParameterId(value.Str)
		}
		return err == nil
	})
	return err
}

func (o HeaderParameterType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := o.MarshalJSON()
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *HeaderParameterType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}

type ListType struct {
	ItemType Type
}

func (o ListType) MarshalJSON() ([]byte, error) {
	type ListTypeAlias ListType
	return safejson.Marshal(ListTypeAlias(o))
}

func (o *ListType) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	value := gjson.ParseBytes(data)
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		switch key.Str {
		case "itemType":
			err = o.ItemType.UnmarshalJSON([]byte(value.Raw))
		}
		return err == nil
	})
	return err
}

func (o ListType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := o.MarshalJSON()
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ListType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}

type MapType struct {
	KeyType   Type
	ValueType Type
}

func (o MapType) MarshalJSON() ([]byte, error) {
	type MapTypeAlias MapType
	return safejson.Marshal(MapTypeAlias(o))
}

func (o *MapType) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	value := gjson.ParseBytes(data)
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		switch key.Str {
		case "keyType":
			err = o.KeyType.UnmarshalJSON([]byte(value.Raw))
		case "valueType":
			err = o.ValueType.UnmarshalJSON([]byte(value.Raw))
		}
		return err == nil
	})
	return err
}

func (o MapType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := o.MarshalJSON()
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *MapType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}

type ObjectDefinition struct {
	TypeName TypeName
	Fields   []FieldDefinition
	Docs     *Documentation
}

func (o ObjectDefinition) MarshalJSON() ([]byte, error) {
	if o.Fields == nil {
		o.Fields = make([]FieldDefinition, 0)
	}
	type ObjectDefinitionAlias ObjectDefinition
	return safejson.Marshal(ObjectDefinitionAlias(o))
}

func (o *ObjectDefinition) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	value := gjson.ParseBytes(data)
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		switch key.Str {
		case "typeName":
			err = o.TypeName.UnmarshalJSON([]byte(value.Raw))
		case "fields":
			if !value.IsArray() {
				err = errors.NewInvalidArgument()
				return false
			}
			value.ForEach(func(_, value gjson.Result) bool {
				var v FieldDefinition
				err = v.UnmarshalJSON([]byte(value.Raw))
				o.Fields = append(o.Fields, v)
				return err == nil
			})
		case "docs":
			if value.Type != gjson.Null {
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var v Documentation
				v = Documentation(value.Str)
				o.Docs = &v
			}
		}
		return err == nil
	})
	return err
}

func (o ObjectDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := o.MarshalJSON()
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ObjectDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}

type OptionalType struct {
	ItemType Type
}

func (o OptionalType) MarshalJSON() ([]byte, error) {
	type OptionalTypeAlias OptionalType
	return safejson.Marshal(OptionalTypeAlias(o))
}

func (o *OptionalType) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	value := gjson.ParseBytes(data)
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		switch key.Str {
		case "itemType":
			err = o.ItemType.UnmarshalJSON([]byte(value.Raw))
		}
		return err == nil
	})
	return err
}

func (o OptionalType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := o.MarshalJSON()
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *OptionalType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}

type PathParameterType struct {
}

type QueryParameterType struct {
	ParamId ParameterId
}

func (o QueryParameterType) MarshalJSON() ([]byte, error) {
	type QueryParameterTypeAlias QueryParameterType
	return safejson.Marshal(QueryParameterTypeAlias(o))
}

func (o *QueryParameterType) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	value := gjson.ParseBytes(data)
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		switch key.Str {
		case "paramId":
			if value.Type != gjson.String {
				err = errors.NewInvalidArgument()
				return false
			}
			o.ParamId = ParameterId(value.Str)
		}
		return err == nil
	})
	return err
}

func (o QueryParameterType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := o.MarshalJSON()
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *QueryParameterType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}

type ServiceDefinition struct {
	ServiceName TypeName
	Endpoints   []EndpointDefinition
	Docs        *Documentation
}

func (o ServiceDefinition) MarshalJSON() ([]byte, error) {
	if o.Endpoints == nil {
		o.Endpoints = make([]EndpointDefinition, 0)
	}
	type ServiceDefinitionAlias ServiceDefinition
	return safejson.Marshal(ServiceDefinitionAlias(o))
}

func (o *ServiceDefinition) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	value := gjson.ParseBytes(data)
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		switch key.Str {
		case "serviceName":
			err = o.ServiceName.UnmarshalJSON([]byte(value.Raw))
		case "endpoints":
			if !value.IsArray() {
				err = errors.NewInvalidArgument()
				return false
			}
			value.ForEach(func(_, value gjson.Result) bool {
				var v EndpointDefinition
				err = v.UnmarshalJSON([]byte(value.Raw))
				o.Endpoints = append(o.Endpoints, v)
				return err == nil
			})
		case "docs":
			if value.Type != gjson.Null {
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var v Documentation
				v = Documentation(value.Str)
				o.Docs = &v
			}
		}
		return err == nil
	})
	return err
}

func (o ServiceDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := o.MarshalJSON()
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ServiceDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}

type SetType struct {
	ItemType Type
}

func (o SetType) MarshalJSON() ([]byte, error) {
	type SetTypeAlias SetType
	return safejson.Marshal(SetTypeAlias(o))
}

func (o *SetType) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	value := gjson.ParseBytes(data)
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		switch key.Str {
		case "itemType":
			err = o.ItemType.UnmarshalJSON([]byte(value.Raw))
		}
		return err == nil
	})
	return err
}

func (o SetType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := o.MarshalJSON()
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SetType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}

type TypeName struct {
	// The name of the custom Conjure type or service. It must be in UpperCamelCase. Numbers are permitted, but not at the beginning of a word. Allowed names: "FooBar", "XYCoordinate", "Build2Request". Disallowed names: "fooBar", "2BuildRequest".
	Name string
	// A period-delimited string of package names. The package names must be lowercase. Numbers are permitted, but not at the beginning of a package name. Allowed packages: "foo", "com.palantir.bar", "com.palantir.foo.thing2". Disallowed packages: "Foo", "com.palantir.foo.2thing".
	Package string
}

func (o TypeName) MarshalJSON() ([]byte, error) {
	type TypeNameAlias TypeName
	return safejson.Marshal(TypeNameAlias(o))
}

func (o *TypeName) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	value := gjson.ParseBytes(data)
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		switch key.Str {
		case "name":
			if value.Type != gjson.String {
				err = errors.NewInvalidArgument()
				return false
			}
			o.Name = value.Str
		case "package":
			if value.Type != gjson.String {
				err = errors.NewInvalidArgument()
				return false
			}
			o.Package = value.Str
		}
		return err == nil
	})
	return err
}

func (o TypeName) MarshalYAML() (interface{}, error) {
	jsonBytes, err := o.MarshalJSON()
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TypeName) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}

type UnionDefinition struct {
	TypeName TypeName
	Union    []FieldDefinition
	Docs     *Documentation
}

func (o UnionDefinition) MarshalJSON() ([]byte, error) {
	if o.Union == nil {
		o.Union = make([]FieldDefinition, 0)
	}
	type UnionDefinitionAlias UnionDefinition
	return safejson.Marshal(UnionDefinitionAlias(o))
}

func (o *UnionDefinition) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	value := gjson.ParseBytes(data)
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		switch key.Str {
		case "typeName":
			err = o.TypeName.UnmarshalJSON([]byte(value.Raw))
		case "union":
			if !value.IsArray() {
				err = errors.NewInvalidArgument()
				return false
			}
			value.ForEach(func(_, value gjson.Result) bool {
				var v FieldDefinition
				err = v.UnmarshalJSON([]byte(value.Raw))
				o.Union = append(o.Union, v)
				return err == nil
			})
		case "docs":
			if value.Type != gjson.Null {
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var v Documentation
				v = Documentation(value.Str)
				o.Docs = &v
			}
		}
		return err == nil
	})
	return err
}

func (o UnionDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := o.MarshalJSON()
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *UnionDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}
