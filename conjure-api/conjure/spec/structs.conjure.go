// This file was generated by Conjure and should not be manually edited.

package spec

import (
	"encoding/json"

	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
	wparams "github.com/palantir/witchcraft-go-params"
	"github.com/tidwall/gjson"
)

type AliasDefinition struct {
	TypeName TypeName       `json:"typeName"`
	Alias    Type           `json:"alias"`
	Docs     *Documentation `json:"docs"`
}

func (o AliasDefinition) MarshalJSON() ([]byte, error) {
	type AliasDefinitionAlias AliasDefinition
	return safejson.Marshal(AliasDefinitionAlias(o))
}

func (o AliasDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

// UnmarshalJSON deserializes data, ignoring unrecognized keys.
// Prefer UnmarshalJSONString if data is already in string form to avoid an extra copy.
func (o *AliasDefinition) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

// UnmarshalJSONString deserializes data, ignoring unrecognized keys.
func (o *AliasDefinition) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), false)
}

// UnmarshalJSONStrict deserializes data, rejecting unrecognized keys.
// Prefer UnmarshalJSONStringStrict if data is already in string form to avoid an extra copy.
func (o *AliasDefinition) UnmarshalJSONStrict(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), true)
}

// UnmarshalJSONStringStrict deserializes data, rejecting unrecognized keys.
func (o *AliasDefinition) UnmarshalJSONStringStrict(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), true)
}

// UnmarshalYAML implements yaml.Unmarshaler. It converts the YAML to JSON, then runs UnmarshalJSON.
func (o *AliasDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	data, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return errors.WrapWithInvalidArgument(err)
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (o *AliasDefinition) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var seenTypeName bool
	var seenAlias bool
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "typeName":
			seenTypeName = true
			if strict {
				err = o.TypeName.UnmarshalJSONStringStrict(value.Raw)
			} else {
				err = o.TypeName.UnmarshalJSONString(value.Raw)
			}
		case "alias":
			seenAlias = true
			if strict {
				err = o.Alias.UnmarshalJSONStringStrict(value.Raw)
			} else {
				err = o.Alias.UnmarshalJSONString(value.Raw)
			}
		case "docs":
			if value.Type != gjson.Null {
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var optionalValue Documentation
				optionalValue = Documentation(value.Str)
				o.Docs = &optionalValue
			}
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	var missingFields []string
	if !seenTypeName {
		missingFields = append(missingFields, "typeName")
	}
	if !seenAlias {
		missingFields = append(missingFields, "alias")
	}
	if len(missingFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("missingFields", missingFields))
	}
	if strict && len(unrecognizedFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields))
	}
	return nil
}

type ArgumentDefinition struct {
	ArgName   ArgumentName   `json:"argName"`
	Type      Type           `json:"type"`
	ParamType ParameterType  `json:"paramType"`
	Docs      *Documentation `json:"docs"`
	Markers   []Type         `json:"markers"`
	Tags      []string       `json:"tags"`
}

func (o ArgumentDefinition) MarshalJSON() ([]byte, error) {
	if o.Markers == nil {
		o.Markers = make([]Type, 0)
	}
	if o.Tags == nil {
		o.Tags = make([]string, 0)
	}
	type ArgumentDefinitionAlias ArgumentDefinition
	return safejson.Marshal(ArgumentDefinitionAlias(o))
}

func (o ArgumentDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

// UnmarshalJSON deserializes data, ignoring unrecognized keys.
// Prefer UnmarshalJSONString if data is already in string form to avoid an extra copy.
func (o *ArgumentDefinition) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

// UnmarshalJSONString deserializes data, ignoring unrecognized keys.
func (o *ArgumentDefinition) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), false)
}

// UnmarshalJSONStrict deserializes data, rejecting unrecognized keys.
// Prefer UnmarshalJSONStringStrict if data is already in string form to avoid an extra copy.
func (o *ArgumentDefinition) UnmarshalJSONStrict(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), true)
}

// UnmarshalJSONStringStrict deserializes data, rejecting unrecognized keys.
func (o *ArgumentDefinition) UnmarshalJSONStringStrict(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), true)
}

// UnmarshalYAML implements yaml.Unmarshaler. It converts the YAML to JSON, then runs UnmarshalJSON.
func (o *ArgumentDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	data, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return errors.WrapWithInvalidArgument(err)
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (o *ArgumentDefinition) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var seenArgName bool
	var seenType bool
	var seenParamType bool
	o.Markers = make([]Type, 0)
	o.Tags = make([]string, 0)
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "argName":
			seenArgName = true
			if value.Type != gjson.String {
				err = errors.NewInvalidArgument()
				return false
			}
			o.ArgName = ArgumentName(value.Str)
		case "type":
			seenType = true
			if strict {
				err = o.Type.UnmarshalJSONStringStrict(value.Raw)
			} else {
				err = o.Type.UnmarshalJSONString(value.Raw)
			}
		case "paramType":
			seenParamType = true
			if strict {
				err = o.ParamType.UnmarshalJSONStringStrict(value.Raw)
			} else {
				err = o.ParamType.UnmarshalJSONString(value.Raw)
			}
		case "docs":
			if value.Type != gjson.Null {
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var optionalValue Documentation
				optionalValue = Documentation(value.Str)
				o.Docs = &optionalValue
			}
		case "markers":
			if !value.IsArray() {
				err = errors.NewInvalidArgument()
				return false
			}
			value.ForEach(func(_, value gjson.Result) bool {
				var listElement Type
				if strict {
					err = listElement.UnmarshalJSONStringStrict(value.Raw)
				} else {
					err = listElement.UnmarshalJSONString(value.Raw)
				}
				o.Markers = append(o.Markers, listElement)
				return err == nil
			})
		case "tags":
			if !value.IsArray() {
				err = errors.NewInvalidArgument()
				return false
			}
			value.ForEach(func(_, value gjson.Result) bool {
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var listElement string
				listElement = value.Str
				o.Tags = append(o.Tags, listElement)
				return err == nil
			})
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	var missingFields []string
	if !seenArgName {
		missingFields = append(missingFields, "argName")
	}
	if !seenType {
		missingFields = append(missingFields, "type")
	}
	if !seenParamType {
		missingFields = append(missingFields, "paramType")
	}
	if len(missingFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("missingFields", missingFields))
	}
	if strict && len(unrecognizedFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields))
	}
	return nil
}

type BodyParameterType struct {
}

type ConjureDefinition struct {
	Version    int                    `json:"version"`
	Errors     []ErrorDefinition      `json:"errors"`
	Types      []TypeDefinition       `json:"types"`
	Services   []ServiceDefinition    `json:"services"`
	Extensions map[string]interface{} `json:"extensions"`
}

func (o ConjureDefinition) MarshalJSON() ([]byte, error) {
	if o.Errors == nil {
		o.Errors = make([]ErrorDefinition, 0)
	}
	if o.Types == nil {
		o.Types = make([]TypeDefinition, 0)
	}
	if o.Services == nil {
		o.Services = make([]ServiceDefinition, 0)
	}
	if o.Extensions == nil {
		o.Extensions = make(map[string]interface{}, 0)
	}
	type ConjureDefinitionAlias ConjureDefinition
	return safejson.Marshal(ConjureDefinitionAlias(o))
}

func (o ConjureDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

// UnmarshalJSON deserializes data, ignoring unrecognized keys.
// Prefer UnmarshalJSONString if data is already in string form to avoid an extra copy.
func (o *ConjureDefinition) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

// UnmarshalJSONString deserializes data, ignoring unrecognized keys.
func (o *ConjureDefinition) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), false)
}

// UnmarshalJSONStrict deserializes data, rejecting unrecognized keys.
// Prefer UnmarshalJSONStringStrict if data is already in string form to avoid an extra copy.
func (o *ConjureDefinition) UnmarshalJSONStrict(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), true)
}

// UnmarshalJSONStringStrict deserializes data, rejecting unrecognized keys.
func (o *ConjureDefinition) UnmarshalJSONStringStrict(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), true)
}

// UnmarshalYAML implements yaml.Unmarshaler. It converts the YAML to JSON, then runs UnmarshalJSON.
func (o *ConjureDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	data, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return errors.WrapWithInvalidArgument(err)
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (o *ConjureDefinition) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var seenVersion bool
	o.Errors = make([]ErrorDefinition, 0)
	o.Types = make([]TypeDefinition, 0)
	o.Services = make([]ServiceDefinition, 0)
	o.Extensions = make(map[string]interface{}, 0)
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "version":
			seenVersion = true
			if value.Type != gjson.Number {
				err = errors.NewInvalidArgument()
				return false
			}
			o.Version = int(value.Int())
		case "errors":
			if !value.IsArray() {
				err = errors.NewInvalidArgument()
				return false
			}
			value.ForEach(func(_, value gjson.Result) bool {
				var listElement ErrorDefinition
				if strict {
					err = listElement.UnmarshalJSONStringStrict(value.Raw)
				} else {
					err = listElement.UnmarshalJSONString(value.Raw)
				}
				o.Errors = append(o.Errors, listElement)
				return err == nil
			})
		case "types":
			if !value.IsArray() {
				err = errors.NewInvalidArgument()
				return false
			}
			value.ForEach(func(_, value gjson.Result) bool {
				var listElement TypeDefinition
				if strict {
					err = listElement.UnmarshalJSONStringStrict(value.Raw)
				} else {
					err = listElement.UnmarshalJSONString(value.Raw)
				}
				o.Types = append(o.Types, listElement)
				return err == nil
			})
		case "services":
			if !value.IsArray() {
				err = errors.NewInvalidArgument()
				return false
			}
			value.ForEach(func(_, value gjson.Result) bool {
				var listElement ServiceDefinition
				if strict {
					err = listElement.UnmarshalJSONStringStrict(value.Raw)
				} else {
					err = listElement.UnmarshalJSONString(value.Raw)
				}
				o.Services = append(o.Services, listElement)
				return err == nil
			})
		case "extensions":
			if !value.IsObject() {
				err = errors.NewInvalidArgument()
				return false
			}
			if o.Extensions == nil {
				o.Extensions = make(map[string]interface{}, 0)
			}
			value.ForEach(func(key, value gjson.Result) bool {
				if key.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				if value.Type != gjson.JSON && value.Type != gjson.String && value.Type != gjson.Number && value.Type != gjson.True && value.Type != gjson.False {
					err = errors.NewInvalidArgument()
					return false
				}
				var mapKey string
				mapKey = key.Str
				var mapVal interface{}
				mapVal = value.Value()
				o.Extensions[mapKey] = mapVal
				return err == nil
			})
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	var missingFields []string
	if !seenVersion {
		missingFields = append(missingFields, "version")
	}
	if len(missingFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("missingFields", missingFields))
	}
	if strict && len(unrecognizedFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields))
	}
	return nil
}

type CookieAuthType struct {
	CookieName string `json:"cookieName"`
}

func (o CookieAuthType) MarshalJSON() ([]byte, error) {
	type CookieAuthTypeAlias CookieAuthType
	return safejson.Marshal(CookieAuthTypeAlias(o))
}

func (o CookieAuthType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

// UnmarshalJSON deserializes data, ignoring unrecognized keys.
// Prefer UnmarshalJSONString if data is already in string form to avoid an extra copy.
func (o *CookieAuthType) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

// UnmarshalJSONString deserializes data, ignoring unrecognized keys.
func (o *CookieAuthType) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), false)
}

// UnmarshalJSONStrict deserializes data, rejecting unrecognized keys.
// Prefer UnmarshalJSONStringStrict if data is already in string form to avoid an extra copy.
func (o *CookieAuthType) UnmarshalJSONStrict(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), true)
}

// UnmarshalJSONStringStrict deserializes data, rejecting unrecognized keys.
func (o *CookieAuthType) UnmarshalJSONStringStrict(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), true)
}

// UnmarshalYAML implements yaml.Unmarshaler. It converts the YAML to JSON, then runs UnmarshalJSON.
func (o *CookieAuthType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	data, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return errors.WrapWithInvalidArgument(err)
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (o *CookieAuthType) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var seenCookieName bool
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "cookieName":
			seenCookieName = true
			if value.Type != gjson.String {
				err = errors.NewInvalidArgument()
				return false
			}
			o.CookieName = value.Str
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	var missingFields []string
	if !seenCookieName {
		missingFields = append(missingFields, "cookieName")
	}
	if len(missingFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("missingFields", missingFields))
	}
	if strict && len(unrecognizedFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields))
	}
	return nil
}

type EndpointDefinition struct {
	EndpointName EndpointName         `json:"endpointName"`
	HttpMethod   HttpMethod           `json:"httpMethod"`
	HttpPath     HttpPath             `json:"httpPath"`
	Auth         *AuthType            `json:"auth"`
	Args         []ArgumentDefinition `json:"args"`
	Returns      *Type                `json:"returns"`
	Docs         *Documentation       `json:"docs"`
	Deprecated   *Documentation       `json:"deprecated"`
	Markers      []Type               `json:"markers"`
	Tags         []string             `json:"tags"`
}

func (o EndpointDefinition) MarshalJSON() ([]byte, error) {
	if o.Args == nil {
		o.Args = make([]ArgumentDefinition, 0)
	}
	if o.Markers == nil {
		o.Markers = make([]Type, 0)
	}
	if o.Tags == nil {
		o.Tags = make([]string, 0)
	}
	type EndpointDefinitionAlias EndpointDefinition
	return safejson.Marshal(EndpointDefinitionAlias(o))
}

func (o EndpointDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

// UnmarshalJSON deserializes data, ignoring unrecognized keys.
// Prefer UnmarshalJSONString if data is already in string form to avoid an extra copy.
func (o *EndpointDefinition) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

// UnmarshalJSONString deserializes data, ignoring unrecognized keys.
func (o *EndpointDefinition) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), false)
}

// UnmarshalJSONStrict deserializes data, rejecting unrecognized keys.
// Prefer UnmarshalJSONStringStrict if data is already in string form to avoid an extra copy.
func (o *EndpointDefinition) UnmarshalJSONStrict(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), true)
}

// UnmarshalJSONStringStrict deserializes data, rejecting unrecognized keys.
func (o *EndpointDefinition) UnmarshalJSONStringStrict(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), true)
}

// UnmarshalYAML implements yaml.Unmarshaler. It converts the YAML to JSON, then runs UnmarshalJSON.
func (o *EndpointDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	data, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return errors.WrapWithInvalidArgument(err)
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (o *EndpointDefinition) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var seenEndpointName bool
	var seenHttpMethod bool
	var seenHttpPath bool
	o.Args = make([]ArgumentDefinition, 0)
	o.Markers = make([]Type, 0)
	o.Tags = make([]string, 0)
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "endpointName":
			seenEndpointName = true
			if value.Type != gjson.String {
				err = errors.NewInvalidArgument()
				return false
			}
			o.EndpointName = EndpointName(value.Str)
		case "httpMethod":
			seenHttpMethod = true
			if value.Type != gjson.String {
				err = errors.NewInvalidArgument()
				return false
			}
			err = o.HttpMethod.UnmarshalText([]byte(value.Str))
		case "httpPath":
			seenHttpPath = true
			if value.Type != gjson.String {
				err = errors.NewInvalidArgument()
				return false
			}
			o.HttpPath = HttpPath(value.Str)
		case "auth":
			if value.Type != gjson.Null {
				var optionalValue AuthType
				if strict {
					err = optionalValue.UnmarshalJSONStringStrict(value.Raw)
				} else {
					err = optionalValue.UnmarshalJSONString(value.Raw)
				}
				o.Auth = &optionalValue
			}
		case "args":
			if !value.IsArray() {
				err = errors.NewInvalidArgument()
				return false
			}
			value.ForEach(func(_, value gjson.Result) bool {
				var listElement ArgumentDefinition
				if strict {
					err = listElement.UnmarshalJSONStringStrict(value.Raw)
				} else {
					err = listElement.UnmarshalJSONString(value.Raw)
				}
				o.Args = append(o.Args, listElement)
				return err == nil
			})
		case "returns":
			if value.Type != gjson.Null {
				var optionalValue Type
				if strict {
					err = optionalValue.UnmarshalJSONStringStrict(value.Raw)
				} else {
					err = optionalValue.UnmarshalJSONString(value.Raw)
				}
				o.Returns = &optionalValue
			}
		case "docs":
			if value.Type != gjson.Null {
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var optionalValue Documentation
				optionalValue = Documentation(value.Str)
				o.Docs = &optionalValue
			}
		case "deprecated":
			if value.Type != gjson.Null {
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var optionalValue Documentation
				optionalValue = Documentation(value.Str)
				o.Deprecated = &optionalValue
			}
		case "markers":
			if !value.IsArray() {
				err = errors.NewInvalidArgument()
				return false
			}
			value.ForEach(func(_, value gjson.Result) bool {
				var listElement Type
				if strict {
					err = listElement.UnmarshalJSONStringStrict(value.Raw)
				} else {
					err = listElement.UnmarshalJSONString(value.Raw)
				}
				o.Markers = append(o.Markers, listElement)
				return err == nil
			})
		case "tags":
			if !value.IsArray() {
				err = errors.NewInvalidArgument()
				return false
			}
			value.ForEach(func(_, value gjson.Result) bool {
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var listElement string
				listElement = value.Str
				o.Tags = append(o.Tags, listElement)
				return err == nil
			})
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	var missingFields []string
	if !seenEndpointName {
		missingFields = append(missingFields, "endpointName")
	}
	if !seenHttpMethod {
		missingFields = append(missingFields, "httpMethod")
	}
	if !seenHttpPath {
		missingFields = append(missingFields, "httpPath")
	}
	if len(missingFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("missingFields", missingFields))
	}
	if strict && len(unrecognizedFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields))
	}
	return nil
}

type EnumDefinition struct {
	TypeName TypeName              `json:"typeName"`
	Values   []EnumValueDefinition `json:"values"`
	Docs     *Documentation        `json:"docs"`
}

func (o EnumDefinition) MarshalJSON() ([]byte, error) {
	if o.Values == nil {
		o.Values = make([]EnumValueDefinition, 0)
	}
	type EnumDefinitionAlias EnumDefinition
	return safejson.Marshal(EnumDefinitionAlias(o))
}

func (o EnumDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

// UnmarshalJSON deserializes data, ignoring unrecognized keys.
// Prefer UnmarshalJSONString if data is already in string form to avoid an extra copy.
func (o *EnumDefinition) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

// UnmarshalJSONString deserializes data, ignoring unrecognized keys.
func (o *EnumDefinition) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), false)
}

// UnmarshalJSONStrict deserializes data, rejecting unrecognized keys.
// Prefer UnmarshalJSONStringStrict if data is already in string form to avoid an extra copy.
func (o *EnumDefinition) UnmarshalJSONStrict(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), true)
}

// UnmarshalJSONStringStrict deserializes data, rejecting unrecognized keys.
func (o *EnumDefinition) UnmarshalJSONStringStrict(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), true)
}

// UnmarshalYAML implements yaml.Unmarshaler. It converts the YAML to JSON, then runs UnmarshalJSON.
func (o *EnumDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	data, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return errors.WrapWithInvalidArgument(err)
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (o *EnumDefinition) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var seenTypeName bool
	o.Values = make([]EnumValueDefinition, 0)
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "typeName":
			seenTypeName = true
			if strict {
				err = o.TypeName.UnmarshalJSONStringStrict(value.Raw)
			} else {
				err = o.TypeName.UnmarshalJSONString(value.Raw)
			}
		case "values":
			if !value.IsArray() {
				err = errors.NewInvalidArgument()
				return false
			}
			value.ForEach(func(_, value gjson.Result) bool {
				var listElement EnumValueDefinition
				if strict {
					err = listElement.UnmarshalJSONStringStrict(value.Raw)
				} else {
					err = listElement.UnmarshalJSONString(value.Raw)
				}
				o.Values = append(o.Values, listElement)
				return err == nil
			})
		case "docs":
			if value.Type != gjson.Null {
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var optionalValue Documentation
				optionalValue = Documentation(value.Str)
				o.Docs = &optionalValue
			}
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	var missingFields []string
	if !seenTypeName {
		missingFields = append(missingFields, "typeName")
	}
	if len(missingFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("missingFields", missingFields))
	}
	if strict && len(unrecognizedFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields))
	}
	return nil
}

type EnumValueDefinition struct {
	Value      string         `json:"value"`
	Docs       *Documentation `json:"docs"`
	Deprecated *Documentation `json:"deprecated"`
}

func (o EnumValueDefinition) MarshalJSON() ([]byte, error) {
	type EnumValueDefinitionAlias EnumValueDefinition
	return safejson.Marshal(EnumValueDefinitionAlias(o))
}

func (o EnumValueDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

// UnmarshalJSON deserializes data, ignoring unrecognized keys.
// Prefer UnmarshalJSONString if data is already in string form to avoid an extra copy.
func (o *EnumValueDefinition) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

// UnmarshalJSONString deserializes data, ignoring unrecognized keys.
func (o *EnumValueDefinition) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), false)
}

// UnmarshalJSONStrict deserializes data, rejecting unrecognized keys.
// Prefer UnmarshalJSONStringStrict if data is already in string form to avoid an extra copy.
func (o *EnumValueDefinition) UnmarshalJSONStrict(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), true)
}

// UnmarshalJSONStringStrict deserializes data, rejecting unrecognized keys.
func (o *EnumValueDefinition) UnmarshalJSONStringStrict(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), true)
}

// UnmarshalYAML implements yaml.Unmarshaler. It converts the YAML to JSON, then runs UnmarshalJSON.
func (o *EnumValueDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	data, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return errors.WrapWithInvalidArgument(err)
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (o *EnumValueDefinition) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var seenValue bool
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "value":
			seenValue = true
			if value.Type != gjson.String {
				err = errors.NewInvalidArgument()
				return false
			}
			o.Value = value.Str
		case "docs":
			if value.Type != gjson.Null {
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var optionalValue Documentation
				optionalValue = Documentation(value.Str)
				o.Docs = &optionalValue
			}
		case "deprecated":
			if value.Type != gjson.Null {
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var optionalValue Documentation
				optionalValue = Documentation(value.Str)
				o.Deprecated = &optionalValue
			}
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	var missingFields []string
	if !seenValue {
		missingFields = append(missingFields, "value")
	}
	if len(missingFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("missingFields", missingFields))
	}
	if strict && len(unrecognizedFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields))
	}
	return nil
}

type ErrorDefinition struct {
	ErrorName  TypeName          `json:"errorName"`
	Docs       *Documentation    `json:"docs"`
	Namespace  ErrorNamespace    `json:"namespace"`
	Code       ErrorCode         `json:"code"`
	SafeArgs   []FieldDefinition `json:"safeArgs"`
	UnsafeArgs []FieldDefinition `json:"unsafeArgs"`
}

func (o ErrorDefinition) MarshalJSON() ([]byte, error) {
	if o.SafeArgs == nil {
		o.SafeArgs = make([]FieldDefinition, 0)
	}
	if o.UnsafeArgs == nil {
		o.UnsafeArgs = make([]FieldDefinition, 0)
	}
	type ErrorDefinitionAlias ErrorDefinition
	return safejson.Marshal(ErrorDefinitionAlias(o))
}

func (o ErrorDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

// UnmarshalJSON deserializes data, ignoring unrecognized keys.
// Prefer UnmarshalJSONString if data is already in string form to avoid an extra copy.
func (o *ErrorDefinition) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

// UnmarshalJSONString deserializes data, ignoring unrecognized keys.
func (o *ErrorDefinition) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), false)
}

// UnmarshalJSONStrict deserializes data, rejecting unrecognized keys.
// Prefer UnmarshalJSONStringStrict if data is already in string form to avoid an extra copy.
func (o *ErrorDefinition) UnmarshalJSONStrict(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), true)
}

// UnmarshalJSONStringStrict deserializes data, rejecting unrecognized keys.
func (o *ErrorDefinition) UnmarshalJSONStringStrict(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), true)
}

// UnmarshalYAML implements yaml.Unmarshaler. It converts the YAML to JSON, then runs UnmarshalJSON.
func (o *ErrorDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	data, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return errors.WrapWithInvalidArgument(err)
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (o *ErrorDefinition) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var seenErrorName bool
	var seenNamespace bool
	var seenCode bool
	o.SafeArgs = make([]FieldDefinition, 0)
	o.UnsafeArgs = make([]FieldDefinition, 0)
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "errorName":
			seenErrorName = true
			if strict {
				err = o.ErrorName.UnmarshalJSONStringStrict(value.Raw)
			} else {
				err = o.ErrorName.UnmarshalJSONString(value.Raw)
			}
		case "docs":
			if value.Type != gjson.Null {
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var optionalValue Documentation
				optionalValue = Documentation(value.Str)
				o.Docs = &optionalValue
			}
		case "namespace":
			seenNamespace = true
			if value.Type != gjson.String {
				err = errors.NewInvalidArgument()
				return false
			}
			o.Namespace = ErrorNamespace(value.Str)
		case "code":
			seenCode = true
			if value.Type != gjson.String {
				err = errors.NewInvalidArgument()
				return false
			}
			err = o.Code.UnmarshalText([]byte(value.Str))
		case "safeArgs":
			if !value.IsArray() {
				err = errors.NewInvalidArgument()
				return false
			}
			value.ForEach(func(_, value gjson.Result) bool {
				var listElement FieldDefinition
				if strict {
					err = listElement.UnmarshalJSONStringStrict(value.Raw)
				} else {
					err = listElement.UnmarshalJSONString(value.Raw)
				}
				o.SafeArgs = append(o.SafeArgs, listElement)
				return err == nil
			})
		case "unsafeArgs":
			if !value.IsArray() {
				err = errors.NewInvalidArgument()
				return false
			}
			value.ForEach(func(_, value gjson.Result) bool {
				var listElement FieldDefinition
				if strict {
					err = listElement.UnmarshalJSONStringStrict(value.Raw)
				} else {
					err = listElement.UnmarshalJSONString(value.Raw)
				}
				o.UnsafeArgs = append(o.UnsafeArgs, listElement)
				return err == nil
			})
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	var missingFields []string
	if !seenErrorName {
		missingFields = append(missingFields, "errorName")
	}
	if !seenNamespace {
		missingFields = append(missingFields, "namespace")
	}
	if !seenCode {
		missingFields = append(missingFields, "code")
	}
	if len(missingFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("missingFields", missingFields))
	}
	if strict && len(unrecognizedFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields))
	}
	return nil
}

type ExternalReference struct {
	// An identifier for a non-Conjure type which is already defined in a different language (e.g. Java).
	ExternalReference TypeName `json:"externalReference"`
	// Other language generators may use the provided fallback if the non-Conjure type is not available. The ANY PrimitiveType is permissible for all external types, but a more specific definition is preferable.
	Fallback Type `json:"fallback"`
}

func (o ExternalReference) MarshalJSON() ([]byte, error) {
	type ExternalReferenceAlias ExternalReference
	return safejson.Marshal(ExternalReferenceAlias(o))
}

func (o ExternalReference) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

// UnmarshalJSON deserializes data, ignoring unrecognized keys.
// Prefer UnmarshalJSONString if data is already in string form to avoid an extra copy.
func (o *ExternalReference) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

// UnmarshalJSONString deserializes data, ignoring unrecognized keys.
func (o *ExternalReference) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), false)
}

// UnmarshalJSONStrict deserializes data, rejecting unrecognized keys.
// Prefer UnmarshalJSONStringStrict if data is already in string form to avoid an extra copy.
func (o *ExternalReference) UnmarshalJSONStrict(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), true)
}

// UnmarshalJSONStringStrict deserializes data, rejecting unrecognized keys.
func (o *ExternalReference) UnmarshalJSONStringStrict(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), true)
}

// UnmarshalYAML implements yaml.Unmarshaler. It converts the YAML to JSON, then runs UnmarshalJSON.
func (o *ExternalReference) UnmarshalYAML(unmarshal func(interface{}) error) error {
	data, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return errors.WrapWithInvalidArgument(err)
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (o *ExternalReference) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var seenExternalReference bool
	var seenFallback bool
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "externalReference":
			seenExternalReference = true
			if strict {
				err = o.ExternalReference.UnmarshalJSONStringStrict(value.Raw)
			} else {
				err = o.ExternalReference.UnmarshalJSONString(value.Raw)
			}
		case "fallback":
			seenFallback = true
			if strict {
				err = o.Fallback.UnmarshalJSONStringStrict(value.Raw)
			} else {
				err = o.Fallback.UnmarshalJSONString(value.Raw)
			}
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	var missingFields []string
	if !seenExternalReference {
		missingFields = append(missingFields, "externalReference")
	}
	if !seenFallback {
		missingFields = append(missingFields, "fallback")
	}
	if len(missingFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("missingFields", missingFields))
	}
	if strict && len(unrecognizedFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields))
	}
	return nil
}

type FieldDefinition struct {
	FieldName  FieldName      `json:"fieldName"`
	Type       Type           `json:"type"`
	Docs       *Documentation `json:"docs"`
	Deprecated *Documentation `json:"deprecated"`
}

func (o FieldDefinition) MarshalJSON() ([]byte, error) {
	type FieldDefinitionAlias FieldDefinition
	return safejson.Marshal(FieldDefinitionAlias(o))
}

func (o FieldDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

// UnmarshalJSON deserializes data, ignoring unrecognized keys.
// Prefer UnmarshalJSONString if data is already in string form to avoid an extra copy.
func (o *FieldDefinition) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

// UnmarshalJSONString deserializes data, ignoring unrecognized keys.
func (o *FieldDefinition) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), false)
}

// UnmarshalJSONStrict deserializes data, rejecting unrecognized keys.
// Prefer UnmarshalJSONStringStrict if data is already in string form to avoid an extra copy.
func (o *FieldDefinition) UnmarshalJSONStrict(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), true)
}

// UnmarshalJSONStringStrict deserializes data, rejecting unrecognized keys.
func (o *FieldDefinition) UnmarshalJSONStringStrict(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), true)
}

// UnmarshalYAML implements yaml.Unmarshaler. It converts the YAML to JSON, then runs UnmarshalJSON.
func (o *FieldDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	data, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return errors.WrapWithInvalidArgument(err)
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (o *FieldDefinition) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var seenFieldName bool
	var seenType bool
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "fieldName":
			seenFieldName = true
			if value.Type != gjson.String {
				err = errors.NewInvalidArgument()
				return false
			}
			o.FieldName = FieldName(value.Str)
		case "type":
			seenType = true
			if strict {
				err = o.Type.UnmarshalJSONStringStrict(value.Raw)
			} else {
				err = o.Type.UnmarshalJSONString(value.Raw)
			}
		case "docs":
			if value.Type != gjson.Null {
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var optionalValue Documentation
				optionalValue = Documentation(value.Str)
				o.Docs = &optionalValue
			}
		case "deprecated":
			if value.Type != gjson.Null {
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var optionalValue Documentation
				optionalValue = Documentation(value.Str)
				o.Deprecated = &optionalValue
			}
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	var missingFields []string
	if !seenFieldName {
		missingFields = append(missingFields, "fieldName")
	}
	if !seenType {
		missingFields = append(missingFields, "type")
	}
	if len(missingFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("missingFields", missingFields))
	}
	if strict && len(unrecognizedFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields))
	}
	return nil
}

type HeaderAuthType struct {
}

type HeaderParameterType struct {
	ParamId ParameterId `json:"paramId"`
}

func (o HeaderParameterType) MarshalJSON() ([]byte, error) {
	type HeaderParameterTypeAlias HeaderParameterType
	return safejson.Marshal(HeaderParameterTypeAlias(o))
}

func (o HeaderParameterType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

// UnmarshalJSON deserializes data, ignoring unrecognized keys.
// Prefer UnmarshalJSONString if data is already in string form to avoid an extra copy.
func (o *HeaderParameterType) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

// UnmarshalJSONString deserializes data, ignoring unrecognized keys.
func (o *HeaderParameterType) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), false)
}

// UnmarshalJSONStrict deserializes data, rejecting unrecognized keys.
// Prefer UnmarshalJSONStringStrict if data is already in string form to avoid an extra copy.
func (o *HeaderParameterType) UnmarshalJSONStrict(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), true)
}

// UnmarshalJSONStringStrict deserializes data, rejecting unrecognized keys.
func (o *HeaderParameterType) UnmarshalJSONStringStrict(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), true)
}

// UnmarshalYAML implements yaml.Unmarshaler. It converts the YAML to JSON, then runs UnmarshalJSON.
func (o *HeaderParameterType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	data, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return errors.WrapWithInvalidArgument(err)
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (o *HeaderParameterType) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var seenParamId bool
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "paramId":
			seenParamId = true
			if value.Type != gjson.String {
				err = errors.NewInvalidArgument()
				return false
			}
			o.ParamId = ParameterId(value.Str)
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	var missingFields []string
	if !seenParamId {
		missingFields = append(missingFields, "paramId")
	}
	if len(missingFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("missingFields", missingFields))
	}
	if strict && len(unrecognizedFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields))
	}
	return nil
}

type ListType struct {
	ItemType Type `json:"itemType"`
}

func (o ListType) MarshalJSON() ([]byte, error) {
	type ListTypeAlias ListType
	return safejson.Marshal(ListTypeAlias(o))
}

func (o ListType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

// UnmarshalJSON deserializes data, ignoring unrecognized keys.
// Prefer UnmarshalJSONString if data is already in string form to avoid an extra copy.
func (o *ListType) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

// UnmarshalJSONString deserializes data, ignoring unrecognized keys.
func (o *ListType) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), false)
}

// UnmarshalJSONStrict deserializes data, rejecting unrecognized keys.
// Prefer UnmarshalJSONStringStrict if data is already in string form to avoid an extra copy.
func (o *ListType) UnmarshalJSONStrict(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), true)
}

// UnmarshalJSONStringStrict deserializes data, rejecting unrecognized keys.
func (o *ListType) UnmarshalJSONStringStrict(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), true)
}

// UnmarshalYAML implements yaml.Unmarshaler. It converts the YAML to JSON, then runs UnmarshalJSON.
func (o *ListType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	data, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return errors.WrapWithInvalidArgument(err)
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (o *ListType) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var seenItemType bool
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "itemType":
			seenItemType = true
			if strict {
				err = o.ItemType.UnmarshalJSONStringStrict(value.Raw)
			} else {
				err = o.ItemType.UnmarshalJSONString(value.Raw)
			}
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	var missingFields []string
	if !seenItemType {
		missingFields = append(missingFields, "itemType")
	}
	if len(missingFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("missingFields", missingFields))
	}
	if strict && len(unrecognizedFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields))
	}
	return nil
}

type MapType struct {
	KeyType   Type `json:"keyType"`
	ValueType Type `json:"valueType"`
}

func (o MapType) MarshalJSON() ([]byte, error) {
	type MapTypeAlias MapType
	return safejson.Marshal(MapTypeAlias(o))
}

func (o MapType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

// UnmarshalJSON deserializes data, ignoring unrecognized keys.
// Prefer UnmarshalJSONString if data is already in string form to avoid an extra copy.
func (o *MapType) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

// UnmarshalJSONString deserializes data, ignoring unrecognized keys.
func (o *MapType) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), false)
}

// UnmarshalJSONStrict deserializes data, rejecting unrecognized keys.
// Prefer UnmarshalJSONStringStrict if data is already in string form to avoid an extra copy.
func (o *MapType) UnmarshalJSONStrict(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), true)
}

// UnmarshalJSONStringStrict deserializes data, rejecting unrecognized keys.
func (o *MapType) UnmarshalJSONStringStrict(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), true)
}

// UnmarshalYAML implements yaml.Unmarshaler. It converts the YAML to JSON, then runs UnmarshalJSON.
func (o *MapType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	data, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return errors.WrapWithInvalidArgument(err)
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (o *MapType) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var seenKeyType bool
	var seenValueType bool
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "keyType":
			seenKeyType = true
			if strict {
				err = o.KeyType.UnmarshalJSONStringStrict(value.Raw)
			} else {
				err = o.KeyType.UnmarshalJSONString(value.Raw)
			}
		case "valueType":
			seenValueType = true
			if strict {
				err = o.ValueType.UnmarshalJSONStringStrict(value.Raw)
			} else {
				err = o.ValueType.UnmarshalJSONString(value.Raw)
			}
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	var missingFields []string
	if !seenKeyType {
		missingFields = append(missingFields, "keyType")
	}
	if !seenValueType {
		missingFields = append(missingFields, "valueType")
	}
	if len(missingFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("missingFields", missingFields))
	}
	if strict && len(unrecognizedFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields))
	}
	return nil
}

type ObjectDefinition struct {
	TypeName TypeName          `json:"typeName"`
	Fields   []FieldDefinition `json:"fields"`
	Docs     *Documentation    `json:"docs"`
}

func (o ObjectDefinition) MarshalJSON() ([]byte, error) {
	if o.Fields == nil {
		o.Fields = make([]FieldDefinition, 0)
	}
	type ObjectDefinitionAlias ObjectDefinition
	return safejson.Marshal(ObjectDefinitionAlias(o))
}

func (o ObjectDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

// UnmarshalJSON deserializes data, ignoring unrecognized keys.
// Prefer UnmarshalJSONString if data is already in string form to avoid an extra copy.
func (o *ObjectDefinition) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

// UnmarshalJSONString deserializes data, ignoring unrecognized keys.
func (o *ObjectDefinition) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), false)
}

// UnmarshalJSONStrict deserializes data, rejecting unrecognized keys.
// Prefer UnmarshalJSONStringStrict if data is already in string form to avoid an extra copy.
func (o *ObjectDefinition) UnmarshalJSONStrict(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), true)
}

// UnmarshalJSONStringStrict deserializes data, rejecting unrecognized keys.
func (o *ObjectDefinition) UnmarshalJSONStringStrict(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), true)
}

// UnmarshalYAML implements yaml.Unmarshaler. It converts the YAML to JSON, then runs UnmarshalJSON.
func (o *ObjectDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	data, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return errors.WrapWithInvalidArgument(err)
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (o *ObjectDefinition) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var seenTypeName bool
	o.Fields = make([]FieldDefinition, 0)
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "typeName":
			seenTypeName = true
			if strict {
				err = o.TypeName.UnmarshalJSONStringStrict(value.Raw)
			} else {
				err = o.TypeName.UnmarshalJSONString(value.Raw)
			}
		case "fields":
			if !value.IsArray() {
				err = errors.NewInvalidArgument()
				return false
			}
			value.ForEach(func(_, value gjson.Result) bool {
				var listElement FieldDefinition
				if strict {
					err = listElement.UnmarshalJSONStringStrict(value.Raw)
				} else {
					err = listElement.UnmarshalJSONString(value.Raw)
				}
				o.Fields = append(o.Fields, listElement)
				return err == nil
			})
		case "docs":
			if value.Type != gjson.Null {
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var optionalValue Documentation
				optionalValue = Documentation(value.Str)
				o.Docs = &optionalValue
			}
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	var missingFields []string
	if !seenTypeName {
		missingFields = append(missingFields, "typeName")
	}
	if len(missingFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("missingFields", missingFields))
	}
	if strict && len(unrecognizedFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields))
	}
	return nil
}

type OptionalType struct {
	ItemType Type `json:"itemType"`
}

func (o OptionalType) MarshalJSON() ([]byte, error) {
	type OptionalTypeAlias OptionalType
	return safejson.Marshal(OptionalTypeAlias(o))
}

func (o OptionalType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

// UnmarshalJSON deserializes data, ignoring unrecognized keys.
// Prefer UnmarshalJSONString if data is already in string form to avoid an extra copy.
func (o *OptionalType) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

// UnmarshalJSONString deserializes data, ignoring unrecognized keys.
func (o *OptionalType) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), false)
}

// UnmarshalJSONStrict deserializes data, rejecting unrecognized keys.
// Prefer UnmarshalJSONStringStrict if data is already in string form to avoid an extra copy.
func (o *OptionalType) UnmarshalJSONStrict(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), true)
}

// UnmarshalJSONStringStrict deserializes data, rejecting unrecognized keys.
func (o *OptionalType) UnmarshalJSONStringStrict(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), true)
}

// UnmarshalYAML implements yaml.Unmarshaler. It converts the YAML to JSON, then runs UnmarshalJSON.
func (o *OptionalType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	data, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return errors.WrapWithInvalidArgument(err)
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (o *OptionalType) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var seenItemType bool
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "itemType":
			seenItemType = true
			if strict {
				err = o.ItemType.UnmarshalJSONStringStrict(value.Raw)
			} else {
				err = o.ItemType.UnmarshalJSONString(value.Raw)
			}
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	var missingFields []string
	if !seenItemType {
		missingFields = append(missingFields, "itemType")
	}
	if len(missingFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("missingFields", missingFields))
	}
	if strict && len(unrecognizedFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields))
	}
	return nil
}

type PathParameterType struct {
}

type QueryParameterType struct {
	ParamId ParameterId `json:"paramId"`
}

func (o QueryParameterType) MarshalJSON() ([]byte, error) {
	type QueryParameterTypeAlias QueryParameterType
	return safejson.Marshal(QueryParameterTypeAlias(o))
}

func (o QueryParameterType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

// UnmarshalJSON deserializes data, ignoring unrecognized keys.
// Prefer UnmarshalJSONString if data is already in string form to avoid an extra copy.
func (o *QueryParameterType) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

// UnmarshalJSONString deserializes data, ignoring unrecognized keys.
func (o *QueryParameterType) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), false)
}

// UnmarshalJSONStrict deserializes data, rejecting unrecognized keys.
// Prefer UnmarshalJSONStringStrict if data is already in string form to avoid an extra copy.
func (o *QueryParameterType) UnmarshalJSONStrict(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), true)
}

// UnmarshalJSONStringStrict deserializes data, rejecting unrecognized keys.
func (o *QueryParameterType) UnmarshalJSONStringStrict(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), true)
}

// UnmarshalYAML implements yaml.Unmarshaler. It converts the YAML to JSON, then runs UnmarshalJSON.
func (o *QueryParameterType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	data, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return errors.WrapWithInvalidArgument(err)
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (o *QueryParameterType) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var seenParamId bool
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "paramId":
			seenParamId = true
			if value.Type != gjson.String {
				err = errors.NewInvalidArgument()
				return false
			}
			o.ParamId = ParameterId(value.Str)
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	var missingFields []string
	if !seenParamId {
		missingFields = append(missingFields, "paramId")
	}
	if len(missingFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("missingFields", missingFields))
	}
	if strict && len(unrecognizedFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields))
	}
	return nil
}

type ServiceDefinition struct {
	ServiceName TypeName             `json:"serviceName"`
	Endpoints   []EndpointDefinition `json:"endpoints"`
	Docs        *Documentation       `json:"docs"`
}

func (o ServiceDefinition) MarshalJSON() ([]byte, error) {
	if o.Endpoints == nil {
		o.Endpoints = make([]EndpointDefinition, 0)
	}
	type ServiceDefinitionAlias ServiceDefinition
	return safejson.Marshal(ServiceDefinitionAlias(o))
}

func (o ServiceDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

// UnmarshalJSON deserializes data, ignoring unrecognized keys.
// Prefer UnmarshalJSONString if data is already in string form to avoid an extra copy.
func (o *ServiceDefinition) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

// UnmarshalJSONString deserializes data, ignoring unrecognized keys.
func (o *ServiceDefinition) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), false)
}

// UnmarshalJSONStrict deserializes data, rejecting unrecognized keys.
// Prefer UnmarshalJSONStringStrict if data is already in string form to avoid an extra copy.
func (o *ServiceDefinition) UnmarshalJSONStrict(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), true)
}

// UnmarshalJSONStringStrict deserializes data, rejecting unrecognized keys.
func (o *ServiceDefinition) UnmarshalJSONStringStrict(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), true)
}

// UnmarshalYAML implements yaml.Unmarshaler. It converts the YAML to JSON, then runs UnmarshalJSON.
func (o *ServiceDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	data, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return errors.WrapWithInvalidArgument(err)
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (o *ServiceDefinition) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var seenServiceName bool
	o.Endpoints = make([]EndpointDefinition, 0)
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "serviceName":
			seenServiceName = true
			if strict {
				err = o.ServiceName.UnmarshalJSONStringStrict(value.Raw)
			} else {
				err = o.ServiceName.UnmarshalJSONString(value.Raw)
			}
		case "endpoints":
			if !value.IsArray() {
				err = errors.NewInvalidArgument()
				return false
			}
			value.ForEach(func(_, value gjson.Result) bool {
				var listElement EndpointDefinition
				if strict {
					err = listElement.UnmarshalJSONStringStrict(value.Raw)
				} else {
					err = listElement.UnmarshalJSONString(value.Raw)
				}
				o.Endpoints = append(o.Endpoints, listElement)
				return err == nil
			})
		case "docs":
			if value.Type != gjson.Null {
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var optionalValue Documentation
				optionalValue = Documentation(value.Str)
				o.Docs = &optionalValue
			}
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	var missingFields []string
	if !seenServiceName {
		missingFields = append(missingFields, "serviceName")
	}
	if len(missingFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("missingFields", missingFields))
	}
	if strict && len(unrecognizedFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields))
	}
	return nil
}

type SetType struct {
	ItemType Type `json:"itemType"`
}

func (o SetType) MarshalJSON() ([]byte, error) {
	type SetTypeAlias SetType
	return safejson.Marshal(SetTypeAlias(o))
}

func (o SetType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

// UnmarshalJSON deserializes data, ignoring unrecognized keys.
// Prefer UnmarshalJSONString if data is already in string form to avoid an extra copy.
func (o *SetType) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

// UnmarshalJSONString deserializes data, ignoring unrecognized keys.
func (o *SetType) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), false)
}

// UnmarshalJSONStrict deserializes data, rejecting unrecognized keys.
// Prefer UnmarshalJSONStringStrict if data is already in string form to avoid an extra copy.
func (o *SetType) UnmarshalJSONStrict(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), true)
}

// UnmarshalJSONStringStrict deserializes data, rejecting unrecognized keys.
func (o *SetType) UnmarshalJSONStringStrict(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), true)
}

// UnmarshalYAML implements yaml.Unmarshaler. It converts the YAML to JSON, then runs UnmarshalJSON.
func (o *SetType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	data, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return errors.WrapWithInvalidArgument(err)
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (o *SetType) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var seenItemType bool
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "itemType":
			seenItemType = true
			if strict {
				err = o.ItemType.UnmarshalJSONStringStrict(value.Raw)
			} else {
				err = o.ItemType.UnmarshalJSONString(value.Raw)
			}
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	var missingFields []string
	if !seenItemType {
		missingFields = append(missingFields, "itemType")
	}
	if len(missingFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("missingFields", missingFields))
	}
	if strict && len(unrecognizedFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields))
	}
	return nil
}

type TypeName struct {
	// The name of the custom Conjure type or service. It must be in UpperCamelCase. Numbers are permitted, but not at the beginning of a word. Allowed names: "FooBar", "XYCoordinate", "Build2Request". Disallowed names: "fooBar", "2BuildRequest".
	Name string `json:"name"`
	// A period-delimited string of package names. The package names must be lowercase. Numbers are permitted, but not at the beginning of a package name. Allowed packages: "foo", "com.palantir.bar", "com.palantir.foo.thing2". Disallowed packages: "Foo", "com.palantir.foo.2thing".
	Package string `json:"package"`
}

func (o TypeName) MarshalJSON() ([]byte, error) {
	type TypeNameAlias TypeName
	return safejson.Marshal(TypeNameAlias(o))
}

func (o TypeName) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

// UnmarshalJSON deserializes data, ignoring unrecognized keys.
// Prefer UnmarshalJSONString if data is already in string form to avoid an extra copy.
func (o *TypeName) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

// UnmarshalJSONString deserializes data, ignoring unrecognized keys.
func (o *TypeName) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), false)
}

// UnmarshalJSONStrict deserializes data, rejecting unrecognized keys.
// Prefer UnmarshalJSONStringStrict if data is already in string form to avoid an extra copy.
func (o *TypeName) UnmarshalJSONStrict(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), true)
}

// UnmarshalJSONStringStrict deserializes data, rejecting unrecognized keys.
func (o *TypeName) UnmarshalJSONStringStrict(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), true)
}

// UnmarshalYAML implements yaml.Unmarshaler. It converts the YAML to JSON, then runs UnmarshalJSON.
func (o *TypeName) UnmarshalYAML(unmarshal func(interface{}) error) error {
	data, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return errors.WrapWithInvalidArgument(err)
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (o *TypeName) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var seenName bool
	var seenPackage bool
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "name":
			seenName = true
			if value.Type != gjson.String {
				err = errors.NewInvalidArgument()
				return false
			}
			o.Name = value.Str
		case "package":
			seenPackage = true
			if value.Type != gjson.String {
				err = errors.NewInvalidArgument()
				return false
			}
			o.Package = value.Str
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	var missingFields []string
	if !seenName {
		missingFields = append(missingFields, "name")
	}
	if !seenPackage {
		missingFields = append(missingFields, "package")
	}
	if len(missingFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("missingFields", missingFields))
	}
	if strict && len(unrecognizedFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields))
	}
	return nil
}

type UnionDefinition struct {
	TypeName TypeName          `json:"typeName"`
	Union    []FieldDefinition `json:"union"`
	Docs     *Documentation    `json:"docs"`
}

func (o UnionDefinition) MarshalJSON() ([]byte, error) {
	if o.Union == nil {
		o.Union = make([]FieldDefinition, 0)
	}
	type UnionDefinitionAlias UnionDefinition
	return safejson.Marshal(UnionDefinitionAlias(o))
}

func (o UnionDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

// UnmarshalJSON deserializes data, ignoring unrecognized keys.
// Prefer UnmarshalJSONString if data is already in string form to avoid an extra copy.
func (o *UnionDefinition) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

// UnmarshalJSONString deserializes data, ignoring unrecognized keys.
func (o *UnionDefinition) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), false)
}

// UnmarshalJSONStrict deserializes data, rejecting unrecognized keys.
// Prefer UnmarshalJSONStringStrict if data is already in string form to avoid an extra copy.
func (o *UnionDefinition) UnmarshalJSONStrict(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), true)
}

// UnmarshalJSONStringStrict deserializes data, rejecting unrecognized keys.
func (o *UnionDefinition) UnmarshalJSONStringStrict(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), true)
}

// UnmarshalYAML implements yaml.Unmarshaler. It converts the YAML to JSON, then runs UnmarshalJSON.
func (o *UnionDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	data, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return errors.WrapWithInvalidArgument(err)
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (o *UnionDefinition) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var seenTypeName bool
	o.Union = make([]FieldDefinition, 0)
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "typeName":
			seenTypeName = true
			if strict {
				err = o.TypeName.UnmarshalJSONStringStrict(value.Raw)
			} else {
				err = o.TypeName.UnmarshalJSONString(value.Raw)
			}
		case "union":
			if !value.IsArray() {
				err = errors.NewInvalidArgument()
				return false
			}
			value.ForEach(func(_, value gjson.Result) bool {
				var listElement FieldDefinition
				if strict {
					err = listElement.UnmarshalJSONStringStrict(value.Raw)
				} else {
					err = listElement.UnmarshalJSONString(value.Raw)
				}
				o.Union = append(o.Union, listElement)
				return err == nil
			})
		case "docs":
			if value.Type != gjson.Null {
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var optionalValue Documentation
				optionalValue = Documentation(value.Str)
				o.Docs = &optionalValue
			}
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	var missingFields []string
	if !seenTypeName {
		missingFields = append(missingFields, "typeName")
	}
	if len(missingFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("missingFields", missingFields))
	}
	if strict && len(unrecognizedFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields))
	}
	return nil
}
