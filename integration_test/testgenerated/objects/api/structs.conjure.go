// This file was generated by Conjure and should not be manually edited.

package api

import (
	"encoding/json"
	"math"

	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	"github.com/palantir/pkg/binary"
	"github.com/palantir/pkg/boolean"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
	"github.com/palantir/pkg/uuid"
	wparams "github.com/palantir/witchcraft-go-params"
	"github.com/tidwall/gjson"
)

type Basic struct {
	Data string `json:"data"`
}

func (o Basic) MarshalJSON() ([]byte, error) {
	type BasicAlias Basic
	return safejson.Marshal(BasicAlias(o))
}

func (o *Basic) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (o *Basic) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), false)
}

func (o *Basic) UnmarshalStrictJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), true)
}

func (o *Basic) UnmarshalStrictJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), true)
}

func (o *Basic) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var seenData bool
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "data":
			seenData = true
			if value.Type != gjson.String {
				err = errors.NewInvalidArgument()
				return false
			}
			o.Data = value.Str
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	var missingFields []string
	if !seenData {
		missingFields = append(missingFields, "data")
	}
	if len(missingFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("missingFields", missingFields))
	}
	if strict && len(unrecognizedFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields))
	}
	return nil
}

func (o Basic) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Basic) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}

type BinaryMap struct {
	Map map[binary.Binary][]byte `json:"map"`
}

func (o BinaryMap) MarshalJSON() ([]byte, error) {
	if o.Map == nil {
		o.Map = make(map[binary.Binary][]byte, 0)
	}
	type BinaryMapAlias BinaryMap
	return safejson.Marshal(BinaryMapAlias(o))
}

func (o *BinaryMap) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (o *BinaryMap) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), false)
}

func (o *BinaryMap) UnmarshalStrictJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), true)
}

func (o *BinaryMap) UnmarshalStrictJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), true)
}

func (o *BinaryMap) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	o.Map = make(map[binary.Binary][]byte, 0)
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "map":
			if !value.IsObject() {
				err = errors.NewInvalidArgument()
				return false
			}
			if o.Map == nil {
				o.Map = make(map[binary.Binary][]byte, 0)
			}
			value.ForEach(func(key, value gjson.Result) bool {
				if key.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var mapKey binary.Binary
				mapKey = binary.Binary(key.Str)
				var mapVal []byte
				mapVal, err = binary.Binary(value.Str).Bytes()
				o.Map[mapKey] = mapVal
				return err == nil
			})
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	if strict && len(unrecognizedFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields))
	}
	return nil
}

func (o BinaryMap) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BinaryMap) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}

type BooleanIntegerMap struct {
	Map map[boolean.Boolean]int `json:"map"`
}

func (o BooleanIntegerMap) MarshalJSON() ([]byte, error) {
	if o.Map == nil {
		o.Map = make(map[boolean.Boolean]int, 0)
	}
	type BooleanIntegerMapAlias BooleanIntegerMap
	return safejson.Marshal(BooleanIntegerMapAlias(o))
}

func (o *BooleanIntegerMap) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (o *BooleanIntegerMap) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), false)
}

func (o *BooleanIntegerMap) UnmarshalStrictJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), true)
}

func (o *BooleanIntegerMap) UnmarshalStrictJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), true)
}

func (o *BooleanIntegerMap) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	o.Map = make(map[boolean.Boolean]int, 0)
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "map":
			if !value.IsObject() {
				err = errors.NewInvalidArgument()
				return false
			}
			if o.Map == nil {
				o.Map = make(map[boolean.Boolean]int, 0)
			}
			value.ForEach(func(key, value gjson.Result) bool {
				if key.Type != gjson.False && key.Type != gjson.True {
					err = errors.NewInvalidArgument()
					return false
				}
				if value.Type != gjson.Number {
					err = errors.NewInvalidArgument()
					return false
				}
				var mapKey boolean.Boolean
				mapKey = boolean.Boolean(key.Bool())
				var mapVal int
				mapVal = int(value.Int())
				o.Map[mapKey] = mapVal
				return err == nil
			})
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	if strict && len(unrecognizedFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields))
	}
	return nil
}

func (o BooleanIntegerMap) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BooleanIntegerMap) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}

type Collections struct {
	MapVar   map[string][]int   `json:"mapVar"`
	ListVar  []string           `json:"listVar"`
	MultiDim [][]map[string]int `json:"multiDim"`
}

func (o Collections) MarshalJSON() ([]byte, error) {
	if o.MapVar == nil {
		o.MapVar = make(map[string][]int, 0)
	}
	if o.ListVar == nil {
		o.ListVar = make([]string, 0)
	}
	if o.MultiDim == nil {
		o.MultiDim = make([][]map[string]int, 0)
	}
	type CollectionsAlias Collections
	return safejson.Marshal(CollectionsAlias(o))
}

func (o *Collections) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (o *Collections) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), false)
}

func (o *Collections) UnmarshalStrictJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), true)
}

func (o *Collections) UnmarshalStrictJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), true)
}

func (o *Collections) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	o.MapVar = make(map[string][]int, 0)
	o.ListVar = make([]string, 0)
	o.MultiDim = make([][]map[string]int, 0)
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "mapVar":
			if !value.IsObject() {
				err = errors.NewInvalidArgument()
				return false
			}
			if o.MapVar == nil {
				o.MapVar = make(map[string][]int, 0)
			}
			value.ForEach(func(key, value gjson.Result) bool {
				if key.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				if !value.IsArray() {
					err = errors.NewInvalidArgument()
					return false
				}
				var mapKey string
				mapKey = key.Str
				var mapVal []int
				value.ForEach(func(_, value gjson.Result) bool {
					if value.Type != gjson.Number {
						err = errors.NewInvalidArgument()
						return false
					}
					var listElement1 int
					listElement1 = int(value.Int())
					mapVal = append(mapVal, listElement1)
					return err == nil
				})
				o.MapVar[mapKey] = mapVal
				return err == nil
			})
		case "listVar":
			if !value.IsArray() {
				err = errors.NewInvalidArgument()
				return false
			}
			value.ForEach(func(_, value gjson.Result) bool {
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var listElement string
				listElement = value.Str
				o.ListVar = append(o.ListVar, listElement)
				return err == nil
			})
		case "multiDim":
			if !value.IsArray() {
				err = errors.NewInvalidArgument()
				return false
			}
			value.ForEach(func(_, value gjson.Result) bool {
				if !value.IsArray() {
					err = errors.NewInvalidArgument()
					return false
				}
				var listElement []map[string]int
				value.ForEach(func(_, value gjson.Result) bool {
					if !value.IsObject() {
						err = errors.NewInvalidArgument()
						return false
					}
					var listElement1 map[string]int
					if listElement1 == nil {
						listElement1 = make(map[string]int, 0)
					}
					value.ForEach(func(key, value gjson.Result) bool {
						if key.Type != gjson.String {
							err = errors.NewInvalidArgument()
							return false
						}
						if value.Type != gjson.Number {
							err = errors.NewInvalidArgument()
							return false
						}
						var mapKey2 string
						mapKey2 = key.Str
						var mapVal2 int
						mapVal2 = int(value.Int())
						listElement1[mapKey2] = mapVal2
						return err == nil
					})
					listElement = append(listElement, listElement1)
					return err == nil
				})
				o.MultiDim = append(o.MultiDim, listElement)
				return err == nil
			})
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	if strict && len(unrecognizedFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields))
	}
	return nil
}

func (o Collections) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Collections) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}

type Compound struct {
	Obj Collections `json:"obj"`
}

func (o Compound) MarshalJSON() ([]byte, error) {
	type CompoundAlias Compound
	return safejson.Marshal(CompoundAlias(o))
}

func (o *Compound) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (o *Compound) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), false)
}

func (o *Compound) UnmarshalStrictJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), true)
}

func (o *Compound) UnmarshalStrictJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), true)
}

func (o *Compound) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var seenObj bool
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "obj":
			seenObj = true
			err = o.Obj.UnmarshalJSON([]byte(value.Raw))
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	var missingFields []string
	if !seenObj {
		missingFields = append(missingFields, "obj")
	}
	if len(missingFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("missingFields", missingFields))
	}
	if strict && len(unrecognizedFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields))
	}
	return nil
}

func (o Compound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Compound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}

type DoubleObj struct {
	Double         float64  `json:"double"`
	DoubleOptional *float64 `json:"doubleOptional"`
	StrOptional    *string  `json:"strOptional"`
}

func (o DoubleObj) MarshalJSON() ([]byte, error) {
	type DoubleObjAlias DoubleObj
	return safejson.Marshal(DoubleObjAlias(o))
}

func (o *DoubleObj) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (o *DoubleObj) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), false)
}

func (o *DoubleObj) UnmarshalStrictJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), true)
}

func (o *DoubleObj) UnmarshalStrictJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), true)
}

func (o *DoubleObj) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var seenDouble bool
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "double":
			seenDouble = true
			if value.Type != gjson.Number {
				err = errors.NewInvalidArgument()
				return false
			}
			switch value.Type {
			case gjson.Number:
				o.Double = value.Num
			case gjson.String:
				switch value.Str {
				case "NaN":
					o.Double = math.NaN()
				case "Infinity":
					o.Double = math.Inf(1)
				case "-Infinity":
					o.Double = math.Inf(-1)
				default:
					err = errors.NewInvalidArgument()
				}
			default:
				err = errors.NewInvalidArgument()
			}
			o.Double = value.Num
		case "doubleOptional":
			if value.Type != gjson.Null {
				if value.Type != gjson.Number {
					err = errors.NewInvalidArgument()
					return false
				}
				var optionalValue float64
				switch value.Type {
				case gjson.Number:
					optionalValue = value.Num
				case gjson.String:
					switch value.Str {
					case "NaN":
						optionalValue = math.NaN()
					case "Infinity":
						optionalValue = math.Inf(1)
					case "-Infinity":
						optionalValue = math.Inf(-1)
					default:
						err = errors.NewInvalidArgument()
					}
				default:
					err = errors.NewInvalidArgument()
				}
				optionalValue = value.Num
				o.DoubleOptional = &optionalValue
			}
		case "strOptional":
			if value.Type != gjson.Null {
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var optionalValue string
				optionalValue = value.Str
				o.StrOptional = &optionalValue
			}
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	var missingFields []string
	if !seenDouble {
		missingFields = append(missingFields, "double")
	}
	if len(missingFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("missingFields", missingFields))
	}
	if strict && len(unrecognizedFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields))
	}
	return nil
}

func (o DoubleObj) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *DoubleObj) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}

type ExampleUuid struct {
	Uid uuid.UUID `json:"uid"`
}

func (o ExampleUuid) MarshalJSON() ([]byte, error) {
	type ExampleUuidAlias ExampleUuid
	return safejson.Marshal(ExampleUuidAlias(o))
}

func (o *ExampleUuid) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (o *ExampleUuid) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), false)
}

func (o *ExampleUuid) UnmarshalStrictJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), true)
}

func (o *ExampleUuid) UnmarshalStrictJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), true)
}

func (o *ExampleUuid) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var seenUid bool
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "uid":
			seenUid = true
			if value.Type != gjson.String {
				err = errors.NewInvalidArgument()
				return false
			}
			err = o.Uid.UnmarshalText([]byte(value.Str))
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	var missingFields []string
	if !seenUid {
		missingFields = append(missingFields, "uid")
	}
	if len(missingFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("missingFields", missingFields))
	}
	if strict && len(unrecognizedFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields))
	}
	return nil
}

func (o ExampleUuid) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ExampleUuid) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}

type NestedCollections struct {
	Collection map[string][]*string `json:"collection"`
}

func (o NestedCollections) MarshalJSON() ([]byte, error) {
	if o.Collection == nil {
		o.Collection = make(map[string][]*string, 0)
	}
	type NestedCollectionsAlias NestedCollections
	return safejson.Marshal(NestedCollectionsAlias(o))
}

func (o *NestedCollections) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (o *NestedCollections) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), false)
}

func (o *NestedCollections) UnmarshalStrictJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), true)
}

func (o *NestedCollections) UnmarshalStrictJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), true)
}

func (o *NestedCollections) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	o.Collection = make(map[string][]*string, 0)
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "collection":
			if !value.IsObject() {
				err = errors.NewInvalidArgument()
				return false
			}
			if o.Collection == nil {
				o.Collection = make(map[string][]*string, 0)
			}
			value.ForEach(func(key, value gjson.Result) bool {
				if key.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				if !value.IsArray() {
					err = errors.NewInvalidArgument()
					return false
				}
				var mapKey string
				mapKey = key.Str
				var mapVal []*string
				value.ForEach(func(_, value gjson.Result) bool {
					var listElement1 *string
					if value.Type != gjson.Null {
						if value.Type != gjson.String {
							err = errors.NewInvalidArgument()
							return false
						}
						var optionalValue2 string
						optionalValue2 = value.Str
						listElement1 = &optionalValue2
					}
					mapVal = append(mapVal, listElement1)
					return err == nil
				})
				o.Collection[mapKey] = mapVal
				return err == nil
			})
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	if strict && len(unrecognizedFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields))
	}
	return nil
}

func (o NestedCollections) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NestedCollections) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}

// A type using go keywords
type Type struct {
	Type []string          `json:"type"`
	Chan map[string]string `json:"chan"`
}

func (o Type) MarshalJSON() ([]byte, error) {
	if o.Type == nil {
		o.Type = make([]string, 0)
	}
	if o.Chan == nil {
		o.Chan = make(map[string]string, 0)
	}
	type TypeAlias Type
	return safejson.Marshal(TypeAlias(o))
}

func (o *Type) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (o *Type) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), false)
}

func (o *Type) UnmarshalStrictJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), true)
}

func (o *Type) UnmarshalStrictJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), true)
}

func (o *Type) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	o.Type = make([]string, 0)
	o.Chan = make(map[string]string, 0)
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "type":
			if !value.IsArray() {
				err = errors.NewInvalidArgument()
				return false
			}
			value.ForEach(func(_, value gjson.Result) bool {
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var listElement string
				listElement = value.Str
				o.Type = append(o.Type, listElement)
				return err == nil
			})
		case "chan":
			if !value.IsObject() {
				err = errors.NewInvalidArgument()
				return false
			}
			if o.Chan == nil {
				o.Chan = make(map[string]string, 0)
			}
			value.ForEach(func(key, value gjson.Result) bool {
				if key.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				if value.Type != gjson.String {
					err = errors.NewInvalidArgument()
					return false
				}
				var mapKey string
				mapKey = key.Str
				var mapVal string
				mapVal = value.Str
				o.Chan[mapKey] = mapVal
				return err == nil
			})
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	if strict && len(unrecognizedFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields))
	}
	return nil
}

func (o Type) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Type) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return o.UnmarshalJSON(jsonBytes)
}
